# README.md

# Lunar Spoofer

<div align="center">

**System Spoofing & Cleaning Tool**

![Version](https://img.shields.io/badge/version-BETA-purple.svg)
![Python](https://img.shields.io/badge/python-3.8+-blue.svg)
![Platform](https://img.shields.io/badge/platform-windows-lightgrey.svg)

</div>

## Overview

**Lunar Spoofer** is a toolkit for controlling and minimizing a system's identifiable footprint. Intended for research, privacy testing, and controlled security assessments. **Legal warning:** for educational and research use only; misuse is the user's responsibility.

## Key Features (compact)

- **MAC Spoofing**
  - Vendor-based and randomized MAC generation (valid OUIs)
  - Interface auto-detection, verification, and rollback
  - OUI database support

- **Cache & Artifact Cleaning**
  - Targeted cleaning for FiveM, Discord (Stable/Canary/PTB), Steam
  - System temp files, browser caches, and registry sanitization (with backups)

- **Network Stack Reset**
  - DNS flush, Winsock, TCP/IP reset, firewall rule clearing, proxy clearing

- **Hardware & System Info**
  - Live hardware inventory and resource monitoring
  - Disk, BIOS, motherboard IDs, UUIDs and current/spoofed MAC tracking

- **Safety & Reliability**
  - Admin-checks, registry backups, dry-run mode, transactional writes, rollback on failure
  - Threaded operations, progress reporting, timeout and exception handling


> HWID and GUID spoofing modules are in active development.

> ‚ö†Ô∏è For full functionality run the shell as Administrator.

Permitted: academic research, controlled security testing, privacy research.
Prohibited: illegal activity, fraud, unauthorized access, evading sanctions/bans. Use responsibly.

## üö® Critical Disclaimer

**IMPORTANT LEGAL NOTICE**

This software is provided **"AS IS"** without any warranties or guarantees. By using Midnight Spoofer, you acknowledge and agree that:

- The developers **are not responsible** for any system damage, data loss, or hardware issues
- You alone assume **all risks** associated with using this software
- System modifications may cause **instability, crashes, or permanent damage**
- Always **backup your system** before use and test on non-critical machines first

**USE AT YOUR OWN RISK - NO LIABILITY IS ACCEPTED FOR ANY DAMAGES**


# legacy\check_icons.py

# check_icons.py
import os
import tkinter as tk
from tkinter import messagebox

def check_icons():
    print("Verificando arquivos de icone...")

    # Lista de poss√≠veis locais dos √≠cones
    possible_locations = [
        'app.ico',
        'app.png',
        os.path.join('src', 'assets', 'app.ico'),
        os.path.join('assets', 'app.ico'),
        os.path.join('src', 'assets', 'app.png'),
        os.path.join('assets', 'app.png'),
    ]

    found_icons = []
    for icon_path in possible_locations:
        if os.path.exists(icon_path):
            found_icons.append(icon_path)
            print(f"[OK] Encontrado: {icon_path}")
        else:
            print(f"[MISSING] Nao encontrado: {icon_path}")

    if not found_icons:
        print("ERRO: Nenhum arquivo de icone encontrado!")
        print("Criando icone padrao...")
        create_default_icon()
    else:
        print(f"Encontrados {len(found_icons)} arquivo(s) de icone")

    # Testar se os √≠cones podem ser carregados
    test_icon_loading(found_icons)

def create_default_icon():
    """Cria um √≠cone padr√£o se nenhum for encontrado"""
    try:
        from PIL import Image, ImageDraw
        # Cria uma imagem 32x32 com fundo roxo
        img = Image.new('RGB', (32, 32), color='#6b21ff')
        draw = ImageDraw.Draw(img)
        # Desenha um 'M' branco
        draw.text((8, 8), "M", fill='white')
        img.save('app.png')
        print("[SUCCESS] Icone padrao criado: app.png")
    except ImportError:
        print("[WARNING] PIL nao disponivel para criar icone padrao")

def test_icon_loading(icon_paths):
    """Testa se os √≠cones podem ser carregados pelo Tkinter"""
    print("\nTestando carregamento de √≠cones...")

    root = tk.Tk()
    root.withdraw()

    for icon_path in icon_paths:
        try:
            if icon_path.endswith('.ico'):
                root.iconbitmap(icon_path)
                print(f"[SUCCESS] Icone carregado: {icon_path}")
            elif icon_path.endswith('.png'):
                # Tenta carregar como PNG
                from PIL import Image, ImageTk
                img = Image.open(icon_path)
                photo = ImageTk.PhotoImage(img)
                root.iconphoto(True, photo)
                print(f"[SUCCESS] PNG carregado: {icon_path}")
        except Exception as e:
            print(f"[ERROR] Falha ao carregar {icon_path}: {e}")

    root.destroy()

if __name__ == "__main__":
    check_icons()


# legacy\firebase-key.json

{
  "type": "service_account",
  "project_id": "midnight-spf",
  "private_key_id": "62951f288620dc46da07e59b4f063fede00b1a85",
  "private_key": "-----BEGIN PRIVATE KEY-----\nMIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQCg6ZugON1PR21z\nDH/LedZYuqXekq/06km0iquLemz+mF6wrXH9oVUhkMKvtngNg29gKshjM/1Xyq6/\n0hv7FseYRsgHKPiTzh2VUcPL69FHFPRviDlrFYqkQr8nWToZg4LBuDeeLpkOmVrT\nLmzwJyjlEAUCm1/ZAemVpcuwMTTiNpwxAsFUwxfjuwyZnAY7bEjfvPeJW+rJFoLW\nnlR9qUh8ca4yBBT0bAFCvrcSudim7uFfb/6dQdYnAuLEUEyT9UNVV0WM2mxc5zz+\n9d6nVTxkY65QFB6tSEYvUdkZMbJrZWp6tUCFjtTlWRUgM2UmsYrDnOK5uWJL5izg\nbsFS0u1BAgMBAAECggEALlf5rWSTQLEGsbro13aIqFdhTEAdE0Gi5q+Fho9E8vJ5\nWxMpIG4lsZwapja8TtAK9Lx9qCyiC3XhbHeb/W3rIE1KcN148kDLvmSlKocJaBp9\n591pBBFZM8PRgAivtgdtUlO3GQS8qjq6sNXPJD9zBL3fY4fSTBLD7oioqF8Tpw60\ndjS4r94Mz5Shm0L/Z9fsFH22IpPbK0WSEn5SVhqnvr6qtOXGgmC0WxqBRoosqRcE\nB5O0S014b4YQkwhwxoSMh5owBR2Qnoe/0VwIfmh+oXFRpx4HESX3Ft9G12xFu/gK\nwt+Nzzv8mOU59ZBLDtr7TWwtzKfxYxbk8fPbB9JTXQKBgQDLqg6flgrnXva/csvQ\n5oy8B3tWbUTEcbVokHgC/LKMhyRxOQYjxQxXaAawNKd6BH5jQg6kdrB7x47t+Nqr\njJrsCLW716SkbJCH/oR/27LDv562oKrTbJNk2XT7Me/jECqik19ESBZJpIXuMWcM\ngYcsIbQv4zpGvDn1oIOnmEYs8wKBgQDKQyZwKGRHt1m4sYNWlwdYRPBWms8Q+l5N\n02bvNSI4Da6nitdLvhfkZP6hVbsytteqAoeBodgkM+HQgzyc9d2riVsjUTrbbWyp\nIfjvAQE/ldZal/ch5aUMkAd1T2swNLNN+WW8dORGxpIzhaQ7eCZP7L4bp4Ensxhh\nLLrDM6J5+wKBgCuj7ew+P2nijGbrl0bVEBT+WWxkj5a0ctXMFxs0wKGiF6n3ORyT\nDZjxHnXFYpmfuuFT90VAdYKgeTz+1QRrZYrsNtzgUVQ2OyYY4JVxIzYUqlKhzNju\n7ApxGkL1KVzzSt95SrGb7MKs8VHf3h/s5WUMd8rHGuarUJQUaAGSfH8HAoGAcRa4\nkC9VWm/ev5CpEaoiFi19f77RFfoW7kbMH+VCe7rSs6TCmfvwWehKIqTPpRxsWwdN\nAqMeOae0k6Q9KLmjtnx3M7kAQp3dCngPOnsCWq4Jit+68v32mZ6SPPopwWtF8cwH\nISbuV9BBAIOxfvq/2SJSbR3r7emKMRMUXX4qUy8CgYEAnVpUxR1/bmGSspcTVdBE\nq329wAe8O2HB40KZZNdY+At4LOOupyfIsw4gK8xKnbWiLgzpZwZ0NrSZ2BxAEM7Q\nFUMw4XJ/njTOP3zMBXWsVzTcvu4b3BMSg6Dr1WHuvQfQPAM8Abm5R4SkinMdQPEw\nS2qUoWPcZy668eBNlxOoq7Y=\n-----END PRIVATE KEY-----\n",
  "client_email": "firebase-adminsdk-fbsvc@midnight-spf.iam.gserviceaccount.com",
  "client_id": "111579139276631735275",
  "auth_uri": "https://accounts.google.com/o/oauth2/auth",
  "token_uri": "https://oauth2.googleapis.com/token",
  "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
  "client_x509_cert_url": "https://www.googleapis.com/robot/v1/metadata/x509/firebase-adminsdk-fbsvc%40midnight-spf.iam.gserviceaccount.com",
  "universe_domain": "googleapis.com"
}


# legacy\run.py

# run.py
import tkinter as tk
from tkinter import messagebox
import customtkinter as ctk
import sys
import os
from src.auth.auth_system_firebase import AuthSystemFirebase as AuthSystem

# Add src to path
sys.path.append(os.path.join(os.path.dirname(__file__), 'src'))

def check_admin_privileges():
    """Check if running as administrator"""
    try:
        import ctypes
        return ctypes.windll.shell32.IsUserAnAdmin()
    except Exception as e:
        print(f"Admin check failed: {e}")
        return False

def get_icon_path():
    """Get absolute path to icon files"""
    base_dir = os.path.dirname(os.path.abspath(__file__))

    # Try different icon locations
    icon_locations = [
        os.path.join(base_dir, 'app.ico'),
        os.path.join(base_dir, 'src', 'assets', 'app.ico'),
        os.path.join(base_dir, 'assets', 'app.ico'),
    ]

    for icon_path in icon_locations:
        if os.path.exists(icon_path):
            return icon_path

    return None

def set_window_icon(window, icon_path=None):
    """Set window icon with multiple fallback methods"""
    if icon_path is None:
        icon_path = get_icon_path()

    if not icon_path or not os.path.exists(icon_path):
        print("Icon file not found")
        return False

    try:
        # Method 1: Standard iconbitmap
        window.iconbitmap(icon_path)
        return True
    except Exception as e:
        print(f"Method 1 failed: {e}")

    try:
        # Method 2: Use PhotoImage for PNG fallback
        if icon_path.endswith('.png'):
            icon_image = tk.PhotoImage(file=icon_path)
            window.iconphoto(True, icon_image)
            return True
    except Exception as e:
        print(f"Method 2 failed: {e}")

    try:
        # Method 3: Windows API for taskbar
        if os.name == 'nt':
            import ctypes
            from ctypes import wintypes

            # Get window handle
            hwnd = ctypes.windll.user32.GetParent(window.winfo_id())

            # Load icon
            ICON_BIG = 1
            LR_LOADFROMFILE = 0x00000010

            icon_handle = ctypes.windll.user32.LoadImageW(
                0, icon_path, 1, 0, 0, LR_LOADFROMFILE
            )

            if icon_handle:
                WM_SETICON = 0x0080
                ctypes.windll.user32.SendMessageW(hwnd, WM_SETICON, ICON_BIG, icon_handle)
                return True
    except Exception as e:
        print(f"Method 3 failed: {e}")

    return False

def main():
    # Check administrator privileges first
    if not check_admin_privileges():
        root = tk.Tk()
        root.withdraw()

        # Set icon for error dialog
        icon_path = get_icon_path()
        if icon_path:
            try:
                root.iconbitmap(icon_path)
            except:
                pass

        messagebox.showerror("Administrator Rights Required",
                         "‚ùå Midnight Spoofer requires Administrator privileges!\n\n" +
                         "Please run as Administrator to use all features.\n\n" +
                         "Right-click -> Run as administrator")
        root.destroy()
        return

    # Start with login system
    try:
        from src.auth.login_window import LoginApp

        # Get icon path and pass to LoginApp
        icon_path = get_icon_path()
        login_app = LoginApp(icon_path=icon_path)
        login_app.run()
    except Exception as e:
        # Fallback error handling
        root = tk.Tk()
        root.withdraw()

        # Try to set icon
        icon_path = get_icon_path()
        if icon_path:
            try:
                root.iconbitmap(icon_path)
            except:
                pass

        messagebox.showerror("Startup Error", f"Failed to start application: {str(e)}")
        root.destroy()
        sys.exit(1)

if __name__ == "__main__":
    main()


# legacy\script.py

import os
import pathlib

def export_project_structure(root_dir, output_file):
    # Lista de extens√µes de arquivos de c√≥digo (personaliz√°vel)
    code_extensions = {
        '.py', '.js', '.html', '.css', '.java', '.c', '.cpp', '.cs', '.php', '.rb',
        '.go', '.rs', '.ts', '.sql', '.json', '.xml', '.yaml', '.yml', '.md', '.cfg',
        '.conf', '.ini', '.sh', '.bat', '.ps1', '.vue', '.jsx',
        '.tsx', '.scss', '.sass', '.less', '.asm', '.swift', '.kt', '.dart'
    }
    
    with open(output_file, 'w', encoding='utf-8') as outfile:
        for root, dirs, files in os.walk(root_dir):
            # Ignorar pastas de vers√£o (personaliz√°vel)
            ignore_dirs = {'.git', '__pycache__', 'node_modules', 'vendor', 'dist', 'build'}
            dirs[:] = [d for d in dirs if d not in ignore_dirs]
            
            for file in files:
                file_path = pathlib.Path(root) / file
                relative_path = file_path.relative_to(root_dir)
                
                # Verificar se √© um arquivo de c√≥digo
                if file_path.suffix.lower() in code_extensions:
                    try:
                        with open(file_path, 'r', encoding='utf-8') as infile:
                            content = infile.read()
                    except UnicodeDecodeError:
                        try:
                            with open(file_path, 'r', encoding='latin-1') as infile:
                                content = infile.read()
                        except Exception:
                            content = f"[ERRO: N√£o foi poss√≠vel ler o arquivo {relative_path}]\n"
                    except Exception as e:
                        content = f"[ERRO: {str(e)}]\n"

                    # Escrever no arquivo de sa√≠da
                    outfile.write(f"# {relative_path}\n\n")
                    outfile.write(content)
                    outfile.write("\n\n")

if __name__ == "__main__":
    project_root = input("Digite o caminho completo do projeto (ou Enter para usar o diret√≥rio atual): ").strip()
    if not project_root:
        project_root = os.getcwd()
    
    output_filename = "projeto_completo.txt"
    export_project_structure(project_root, output_filename)
    print(f"Arquivo '{output_filename}' gerado com sucesso!")

# legacy\src\auth\auth_system_firebase.py

# src/auth/auth_system_firebase.py
import firebase_admin
from firebase_admin import credentials, firestore, auth
import hashlib
import secrets
from datetime import datetime
from typing import Optional, Dict, Any
import requests
import json
import os
import sys

class AuthSystemFirebase:
    def __init__(self, firebase_cred_path=None):
        # Determinar o caminho correto para o arquivo de credenciais
        if firebase_cred_path is None:
            if getattr(sys, 'frozen', False):
                # Execut√°vel PyInstaller
                base_path = sys._MEIPASS
                firebase_cred_path = os.path.join(base_path, 'firebase-key.json')
            else:
                # Desenvolvimento
                firebase_cred_path = 'firebase-key.json'

        print(f"üîç Procurando arquivo Firebase em: {firebase_cred_path}")

        # Verificar se o arquivo existe
        if not os.path.exists(firebase_cred_path):
            print(f"‚ùå Arquivo Firebase n√£o encontrado: {firebase_cred_path}")
            # Tentar caminho alternativo
            alt_path = os.path.join(os.getcwd(), 'firebase-key.json')
            print(f"üîç Tentando caminho alternativo: {alt_path}")
            if os.path.exists(alt_path):
                firebase_cred_path = alt_path
                print("‚úÖ Arquivo encontrado no caminho alternativo")
            else:
                raise FileNotFoundError(f"Arquivo Firebase n√£o encontrado em nenhum dos caminhos: {firebase_cred_path}, {alt_path}")

        # Inicializar Firebase
        try:
            if not firebase_admin._apps:
                cred = credentials.Certificate(firebase_cred_path)
                firebase_admin.initialize_app(cred)

            self.db = firestore.client()
            self.licenses_ref = self.db.collection('licenses')
            self.users_ref = self.db.collection('users')
            print("‚úÖ Firebase conectado com sucesso!")

        except Exception as e:
            print(f"‚ùå Erro ao conectar Firebase: {e}")
            raise

    def validate_license(self, license_key: str) -> bool:
        """Valida licen√ßa NO FIREBASE - imposs√≠vel burlar"""
        try:
            print(f"üîç Validando licen√ßa: {license_key}")
            
            # Busca licen√ßa no Firebase
            license_doc = self.licenses_ref.document(license_key).get()
            
            if not license_doc.exists:
                print("‚ùå Licen√ßa n√£o existe no Firebase")
                return False
            
            license_data = license_doc.to_dict()
            print(f"üìã Dados da licen√ßa: {license_data}")
            
            # Verifica se j√° foi usada
            if license_data.get('used', False):
                print("‚ùå Licen√ßa j√° foi usada")
                return False
                
            # Verifica se est√° ativa
            if not license_data.get('active', True):
                print("‚ùå Licen√ßa inativa")
                return False
                
            # Verifica se expirou
            expires_at = license_data.get('expires_at')
            if expires_at:
                from datetime import datetime
                if datetime.now() > datetime.fromisoformat(expires_at):
                    print("‚ùå Licen√ßa expirada")
                    return False
                
            print("‚úÖ Licen√ßa v√°lida!")
            return True
            
        except Exception as e:
            print(f"‚ùå Erro ao validar licen√ßa: {e}")
            return False

    def check_user_exists(self, username: str, email: str) -> Dict[str, bool]:
        """Verifica se username ou email j√° existem"""
        result = {'username_exists': False, 'email_exists': False}

        try:
            # Verifica email no Firebase Auth
            try:
                auth.get_user_by_email(email)
                result['email_exists'] = True
            except auth.UserNotFoundError:
                pass
            except Exception as e:
                print(f"‚ö†Ô∏è Erro ao verificar email: {e}")

            # Verifica username no Firestore
            try:
                user_docs = self.users_ref.where('username', '==', username).limit(1).get()
                if user_docs:
                    result['username_exists'] = True
            except Exception as e:
                print(f"‚ö†Ô∏è Erro ao verificar username: {e}")

        except Exception as e:
            print(f"‚ùå Erro geral na verifica√ß√£o: {e}")

        return result

    def register_user(self, username: str, email: str, password: str, license_key: str) -> bool:
        """Registra usu√°rio COM VALIDA√á√ÉO NO FIREBASE - CORRIGIDO"""
        try:
            print(f"üë§ Registrando usu√°rio: {username}, email: {email}")

            # 1. Valida licen√ßa no Firebase
            if not self.validate_license(license_key):
                print("‚ùå Licen√ßa inv√°lida")
                return False

            # 2. Verifica se email j√° existe ANTES de tentar criar
            try:
                print(f"üîç Verificando se email j√° existe: {email}")
                existing_user = auth.get_user_by_email(email)
                print(f"‚ùå Email j√° est√° em uso: {email}")
                return False
            except auth.UserNotFoundError:
                print("‚úÖ Email dispon√≠vel")
                pass  # Email n√£o existe, pode continuar
            except Exception as e:
                print(f"‚ö†Ô∏è Erro ao verificar email: {e}")
                # Continua mesmo com erro na verifica√ß√£o

            # 3. Verifica se username j√° existe no Firestore
            try:
                print(f"üîç Verificando se username j√° existe: {username}")
                user_docs = self.users_ref.where('username', '==', username).limit(1).get()
                if user_docs:
                    print(f"‚ùå Username j√° est√° em uso: {username}")
                    return False
                print("‚úÖ Username dispon√≠vel")
            except Exception as e:
                print(f"‚ö†Ô∏è Erro ao verificar username: {e}")

            # 4. Cria usu√°rio no Firebase Auth
            try:
                print("üöÄ Criando usu√°rio no Firebase Auth...")
                user_record = auth.create_user(
                    email=email,
                    password=password,
                    display_name=username
                )
                print(f"‚úÖ Usu√°rio criado no Auth: {user_record.uid}")

                # 5. Marca licen√ßa como usada
                print("üè∑Ô∏è Marcando licen√ßa como usada...")
                self.licenses_ref.document(license_key).update({
                    'used': True,
                    'used_by': user_record.uid,
                    'used_at': datetime.now().isoformat(),
                    'used_by_username': username
                })
                print("‚úÖ Licen√ßa marcada como usada")

                # 6. Salva dados adicionais no Firestore
                print("üíæ Salvando dados no Firestore...")
                self.users_ref.document(user_record.uid).set({
                    'username': username,
                    'email': email,
                    'license_key': license_key,
                    'created_at': datetime.now().isoformat(),
                    'last_login': datetime.now().isoformat(),
                    'is_active': True,
                    'user_id': user_record.uid
                })
                print("‚úÖ Dados salvos no Firestore")
                return True

            except auth.EmailAlreadyExistsError:
                print("‚ùå Email j√° est√° em uso (durante cria√ß√£o)")
                return False
            except Exception as e:
                print(f"‚ùå Erro durante cria√ß√£o do usu√°rio: {e}")
                # Tenta limpar usu√°rio criado parcialmente
                try:
                    if 'user_record' in locals():
                        auth.delete_user(user_record.uid)
                        print("üßπ Usu√°rio removido do Auth devido a erro")
                except:
                    pass
                return False

        except Exception as e:
            print(f"‚ùå Erro cr√≠tico no registro: {e}")
            return False

    def verify_login(self, email: str, password: str) -> bool:
        """Verifica login - SIMPLIFICADO para demo"""
        try:
            print(f"üîê Verificando login para: {email}")
            
            # Em produ√ß√£o, voc√™ usaria Firebase Auth REST API
            # Para demo, vamos verificar se o email existe
            user_docs = self.users_ref.where('email', '==', email).limit(1).get()
            
            if not user_docs:
                print("‚ùå Usu√°rio n√£o encontrado")
                return False
                
            # Atualiza √∫ltimo login
            for doc in user_docs:
                self.users_ref.document(doc.id).update({
                    'last_login': datetime.now().isoformat()
                })
                print(f"‚úÖ Login bem-sucedido para: {email}")
                
            return True
            
        except Exception as e:
            print(f"‚ùå Erro no login: {e}")
            return False

    def cleanup_test_data(self, email: str, username: str):
        """Remove dados de teste (use com cuidado!)"""
        try:
            # Encontra usu√°rio pelo email
            user = auth.get_user_by_email(email)

            # Remove do Auth
            auth.delete_user(user.uid)
            print(f"‚úÖ Usu√°rio removido do Auth: {user.uid}")

            # Remove do Firestore
            self.users_ref.document(user.uid).delete()
            print(f"‚úÖ Usu√°rio removido do Firestore: {user.uid}")

            # NOTA: Licen√ßa n√£o √© liberada automaticamente
            print("‚ö†Ô∏è Licen√ßa precisa ser resetada manualmente no Firebase")

        except auth.UserNotFoundError:
            print("‚ùå Usu√°rio n√£o encontrado no Auth")
        except Exception as e:
            print(f"‚ùå Erro na limpeza: {e}")

    def get_user_info(self, email: str) -> Optional[Dict[str, Any]]:
        """Busca informa√ß√µes do usu√°rio"""
        try:
            user_docs = self.users_ref.where('email', '==', email).limit(1).get()

            for doc in user_docs:
                user_data = doc.to_dict()
                return user_data

            return None

        except Exception as e:
            print(f"Erro ao buscar usu√°rio: {e}")
            return None


# legacy\src\auth\license_generator.py

import secrets
import string
import json
import os
from datetime import datetime

class LicenseGenerator:
    """Generate license keys for Midnight Spoofer"""

    def __init__(self):
        self.license_format = "MDSF-{segment1}-{segment2}-{segment3}"

    def generate_license_key(self) -> str:
        """Generate a single license key in MDSF-XXXX-XXXX-XXXX format"""
        segments = []
        for _ in range(3):
            segment = ''.join(secrets.choice(string.ascii_uppercase + string.digits)
                             for _ in range(4))
            segments.append(segment)
        return f"MDSF-{'-'.join(segments)}"

    def generate_multiple_keys(self, count: int) -> list[str]:
        """Generate multiple unique license keys"""
        keys = set()
        while len(keys) < count:
            keys.add(self.generate_license_key())
        return list(keys)

    def save_keys_to_file(self, keys: list[str], filename: str = "license_keys.txt"):
        """Save license keys to a file with metadata"""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

        with open(filename, 'w', encoding='utf-8') as f:
            f.write(f"# Midnight Spoofer License Keys\n")
            f.write(f"# Generated: {timestamp}\n")
            f.write(f"# Total Keys: {len(keys)}\n")
            f.write("#" + "="*50 + "\n\n")

            for i, key in enumerate(keys, 1):
                f.write(f"{key}\n")

        print(f"Generated {len(keys)} license keys and saved to {filename}")

    def validate_license_format(self, license_key: str) -> bool:
        """Validate license key format"""
        if not license_key or not license_key.startswith("MDSF-"):
            return False

        parts = license_key.split("-")
        if len(parts) != 4:
            return False

        # Check each segment
        for part in parts[1:]:
            if len(part) != 4:
                return False
            if not all(c in string.ascii_uppercase + string.digits for c in part):
                return False

        return True

def main():
    """Command line interface for license generation"""
    generator = LicenseGenerator()

    try:
        count = int(input("How many license keys to generate? "))
        if count <= 0:
            print("Please enter a positive number")
            return

        keys = generator.generate_multiple_keys(count)

        # Save to file
        filename = f"license_keys_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt"
        generator.save_keys_to_file(keys, filename)

        # Display first few keys
        print(f"\nFirst {min(5, len(keys))} keys:")
        for key in keys[:5]:
            print(f"  {key}")

        if len(keys) > 5:
            print(f"  ... and {len(keys) - 5} more")

    except ValueError:
        print("Please enter a valid number")
    except KeyboardInterrupt:
        print("\nOperation cancelled")

if __name__ == "__main__":
    main()


# legacy\src\auth\login_window.py

import tkinter as tk
from tkinter import messagebox, ttk
import customtkinter as ctk
from .auth_system_firebase import AuthSystemFirebase
import sys
import os

# Add parent directory to path for imports
sys.path.append(os.path.join(os.path.dirname(__file__), '..'))

class LoginApp:
    def __init__(self, icon_path=None):
        self.auth = AuthSystemFirebase()
        self.current_user = None
        self.icon_path = icon_path
        self.setup_login_window()

    def setup_login_window(self):
        """Initialize the main login window"""
        self.window = ctk.CTk()
        self.window.title("Midnight Spoofer - Login")
        self.window.geometry("450x600")
        self.window.resizable(False, False)

        # Center window
        self.window.update_idletasks()
        width = self.window.winfo_width()
        height = self.window.winfo_height()
        x = (self.window.winfo_screenwidth() // 2) - (width // 2)
        y = (self.window.winfo_screenheight() // 2) - (height // 2)
        self.window.geometry(f'{width}x{height}+{x}+{y}')

        # Theme setup
        ctk.set_appearance_mode("dark")
        ctk.set_default_color_theme("blue")

        # Set icon
        self.set_window_icon()

        self.create_login_frame()

    def set_window_icon(self):
        """Set window icon with multiple attempts"""
        if not self.icon_path or not os.path.exists(self.icon_path):
            print("Icon path not available for login window")
            return

        try:
            # Multiple attempts with delays
            attempts = [
                (100, self._set_icon_attempt1),
                (500, self._set_icon_attempt2),
                (1000, self._set_icon_attempt3),
            ]

            for delay, method in attempts:
                self.window.after(delay, method)

        except Exception as e:
            print(f"Icon setting failed: {e}")

    def _set_icon_attempt1(self):
        """First attempt: standard method"""
        try:
            self.window.iconbitmap(self.icon_path)
            print("Login window icon set (attempt 1)")
        except Exception as e:
            print(f"Attempt 1 failed: {e}")

    def _set_icon_attempt2(self):
        """Second attempt: after window is fully loaded"""
        try:
            if hasattr(self, 'window') and self.window.winfo_exists():
                self.window.iconbitmap(self.icon_path)
                print("Login window icon set (attempt 2)")
        except Exception as e:
            print(f"Attempt 2 failed: {e}")

    def _set_icon_attempt3(self):
        """Third attempt: Windows API"""
        try:
            if os.name == 'nt' and hasattr(self, 'window'):
                import ctypes
                from ctypes import wintypes

                hwnd = ctypes.windll.user32.GetParent(self.window.winfo_id())

                # Ensure window appears in taskbar
                GWL_EXSTYLE = -20
                WS_EX_APPWINDOW = 0x00040000
                style = ctypes.windll.user32.GetWindowLongW(hwnd, GWL_EXSTYLE)
                ctypes.windll.user32.SetWindowLongW(hwnd, GWL_EXSTYLE, style | WS_EX_APPWINDOW)

                # Set icon
                ICON_BIG = 1
                LR_LOADFROMFILE = 0x00000010

                icon_handle = ctypes.windll.user32.LoadImageW(
                    0, self.icon_path, 1, 0, 0, LR_LOADFROMFILE
                )

                if icon_handle:
                    WM_SETICON = 0x0080
                    ctypes.windll.user32.SendMessageW(hwnd, WM_SETICON, ICON_BIG, icon_handle)
                    print("Login window icon set (attempt 3 - Windows API)")

        except Exception as e:
            print(f"Attempt 3 failed: {e}")

    def create_login_frame(self):
        """Create the main login interface"""
        # Main frame
        self.main_frame = ctk.CTkFrame(self.window, corner_radius=15)
        self.main_frame.pack(pady=40, padx=40, fill="both", expand=True)

        # Logo/Title
        title = ctk.CTkLabel(
            self.main_frame,
            text="üöÄ MIDNIGHT SPOOFER",
            font=ctk.CTkFont(family="Segoe UI", size=24, weight="bold"),
            text_color="#6b21ff"
        )
        title.pack(pady=30)

        # Subtitle
        subtitle = ctk.CTkLabel(
            self.main_frame,
            text="Advanced System Identity Protection",
            font=ctk.CTkFont(size=12),
            text_color="#b0b0ff"
        )
        subtitle.pack(pady=(0, 30))

        # Login form container
        self.login_container = ctk.CTkFrame(self.main_frame, fg_color="transparent")
        self.login_container.pack(fill="both", expand=True, padx=20)

        # Username field
        self.username_entry = ctk.CTkEntry(
            self.login_container,
            placeholder_text="Email",
            width=300,
            height=45,
            font=ctk.CTkFont(size=14)
        )
        self.username_entry.pack(pady=10)

        # Password field
        self.password_entry = ctk.CTkEntry(
            self.login_container,
            placeholder_text="Password",
            show="‚Ä¢",
            width=300,
            height=45,
            font=ctk.CTkFont(size=14)
        )
        self.password_entry.pack(pady=10)

        # Login button
        login_btn = ctk.CTkButton(
            self.login_container,
            text="LOGIN",
            command=self.login,
            width=300,
            height=45,
            font=ctk.CTkFont(size=16, weight="bold"),
            fg_color="#6b21ff",
            hover_color="#4a1c6d"
        )
        login_btn.pack(pady=15)

        # Create Account button
        create_btn = ctk.CTkButton(
            self.login_container,
            text="CREATE ACCOUNT",
            command=self.show_license_activation,
            width=300,
            height=45,
            fg_color="transparent",
            border_width=2,
            border_color="#6b21ff",
            font=ctk.CTkFont(size=14, weight="bold"),
            text_color="#6b21ff"
        )
        create_btn.pack(pady=15)

        # Bind Enter key to login
        self.window.bind('<Return>', lambda e: self.login())

    def show_register(self):
        """Show registration dialog"""
        # Hide main login
        self.main_frame.pack_forget()

        # Create registration frame
        self.register_frame = ctk.CTkFrame(self.window, corner_radius=15)
        self.register_frame.pack(pady=40, padx=40, fill="both", expand=True)

        # Title
        title = ctk.CTkLabel(
            self.register_frame,
            text="CREATE NEW ACCOUNT",
            font=ctk.CTkFont(family="Segoe UI", size=20, weight="bold"),
            text_color="#6b21ff"
        )
        title.pack(pady=20)

        # Form container
        form_frame = ctk.CTkFrame(self.register_frame, fg_color="transparent")
        form_frame.pack(fill="both", expand=True, padx=20, pady=10)

        # Registration fields
        self.reg_entries = {}

        fields = [
            ("Username", "username"),
            ("Email", "email"),
            ("Password", "password"),
            ("Confirm Password", "confirm_password"),
            ("License Key", "license_key")
        ]

        for label, key in fields:
            entry = ctk.CTkEntry(
                form_frame,
                placeholder_text=label,
                show="‚Ä¢" if "password" in key else "",
                width=300,
                height=40,
                font=ctk.CTkFont(size=12)
            )
            entry.pack(pady=8)
            self.reg_entries[key] = entry

        # Register button
        register_btn = ctk.CTkButton(
            form_frame,
            text="REGISTER",
            command=self.register,
            width=300,
            height=45,
            font=ctk.CTkFont(size=14, weight="bold"),
            fg_color="#00ff88",
            hover_color="#00cc66"
        )
        register_btn.pack(pady=20)

        # Back button
        back_btn = ctk.CTkButton(
            form_frame,
            text="‚Üê BACK TO LOGIN",
            command=self.show_login,
            width=300,
            height=35,
            fg_color="transparent",
            font=ctk.CTkFont(size=12),
            text_color="#888888"
        )
        back_btn.pack(pady=5)

    def show_license_activation(self):
        """Show license activation dialog for account creation"""
        # Hide main login
        self.main_frame.pack_forget()

        # Create license frame
        self.license_frame = ctk.CTkFrame(self.window, corner_radius=15)
        self.license_frame.pack(pady=40, padx=40, fill="both", expand=True)

        # Title
        title = ctk.CTkLabel(
            self.license_frame,
            text="ENTER LICENSE KEY",
            font=ctk.CTkFont(family="Segoe UI", size=20, weight="bold"),
            text_color="#6b21ff"
        )
        title.pack(pady=30)

        # Description
        desc = ctk.CTkLabel(
            self.license_frame,
            text="Enter your license key to create an account",
            font=ctk.CTkFont(size=12),
            text_color="#b0b0ff"
        )
        desc.pack(pady=(0, 20))

        # License key entry
        self.license_entry = ctk.CTkEntry(
            self.license_frame,
            placeholder_text="XXXX-XXXX-XXXX-XXXX",
            width=300,
            height=45,
            font=ctk.CTkFont(size=14, weight="bold"),
            justify="center"
        )
        self.license_entry.pack(pady=20)

        # Next button
        next_btn = ctk.CTkButton(
            self.license_frame,
            text="NEXT",
            command=self.validate_license_and_show_register,
            width=300,
            height=45,
            font=ctk.CTkFont(size=16, weight="bold"),
            fg_color="#00ff88",
            hover_color="#00cc66"
        )
        next_btn.pack(pady=20)

        # Back button
        back_btn = ctk.CTkButton(
            self.license_frame,
            text="‚Üê BACK",
            command=self.show_login,
            width=300,
            height=35,
            fg_color="transparent",
            font=ctk.CTkFont(size=12),
            text_color="#888888"
        )
        back_btn.pack(pady=10)

    def show_login(self):
        """Return to login screen - CORRIGIDO"""
        try:
            # Hide other frames
            if hasattr(self, 'register_frame') and self.register_frame:
                self.register_frame.pack_forget()
                self.register_frame.destroy()
                delattr(self, 'register_frame')

            if hasattr(self, 'license_frame') and self.license_frame:
                self.license_frame.pack_forget()
                self.license_frame.destroy()
                delattr(self, 'license_frame')

            # Clear any stored license
            if hasattr(self, 'validated_license'):
                delattr(self, 'validated_license')

            # Ensure main login frame is visible
            if hasattr(self, 'main_frame'):
                self.main_frame.pack(pady=40, padx=40, fill="both", expand=True)

        except Exception as e:
            print(f"Error in show_login: {e}")
            # Fallback: recriar a interface completa se necess√°rio
            self.setup_login_window()

    def login(self):
        """Handle login attempt"""
        username = self.username_entry.get().strip()
        password = self.password_entry.get()

        if not username or not password:
            messagebox.showerror("Error", "Please enter both username and password")
            return

        if self.auth.verify_login(username, password):
            self.current_user = username
            self.window.destroy()
            # Start main application
            self.start_main_app()
        else:
            messagebox.showerror("Login Failed", "Invalid username or password")

    def register(self):
        """Handle user registration - CORRIGIDO"""
        data = {}
        for key, entry in self.reg_entries.items():
            data[key] = entry.get().strip()

        # Validation
        if not all(data.values()):
            messagebox.showerror("Error", "All fields are required")
            return

        if data['password'] != data['confirm_password']:
            messagebox.showerror("Error", "Passwords do not match")
            return

        if len(data['password']) < 6:
            messagebox.showerror("Error", "Password must be at least 6 characters")
            return

        if not self.auth.validate_license(data['license_key']):
            messagebox.showerror("Error", "Invalid or already used license key")
            return

        # Attempt registration
        if self.auth.register_user(data['username'], data['email'], data['password'], data['license_key']):
            messagebox.showinfo("Success", "Account created successfully! Please login.")

            # CORRE√á√ÉO: Redirecionar para login e preencher email
            self.show_login()
            self.username_entry.delete(0, 'end')
            self.username_entry.insert(0, data['email'])
            self.password_entry.focus_set()

        else:
            messagebox.showerror("Error", "Username, email, or license key already exists")

    def validate_license_and_show_register(self):
        """Validate license key and show registration form"""
        license_key = self.license_entry.get().strip()

        if not license_key:
            messagebox.showerror("Error", "Please enter a license key")
            return

        if self.auth.validate_license(license_key):
            # Store the validated license key
            self.validated_license = license_key
            # Show registration form
            self.show_register_from_license()
        else:
            messagebox.showerror("Error", "License key is invalid or already in use")

    def show_register_from_license(self):
        """Show registration form after license validation"""
        # Hide license frame
        self.license_frame.pack_forget()

        # Create registration frame
        self.register_frame = ctk.CTkFrame(self.window, corner_radius=15)
        self.register_frame.pack(pady=40, padx=40, fill="both", expand=True)

        # Title
        title = ctk.CTkLabel(
            self.register_frame,
            text="CREATE YOUR ACCOUNT",
            font=ctk.CTkFont(family="Segoe UI", size=20, weight="bold"),
            text_color="#6b21ff"
        )
        title.pack(pady=20)

        # Form container
        form_frame = ctk.CTkFrame(self.register_frame, fg_color="transparent")
        form_frame.pack(fill="both", expand=True, padx=20, pady=10)

        # Registration fields (without license key since it's already validated)
        self.reg_entries = {}

        fields = [
            ("Username", "username"),
            ("Email", "email"),
            ("Password", "password"),
            ("Confirm Password", "confirm_password")
        ]

        for label, key in fields:
            entry = ctk.CTkEntry(
                form_frame,
                placeholder_text=label,
                show="‚Ä¢" if "password" in key else "",
                width=300,
                height=40,
                font=ctk.CTkFont(size=12)
            )
            entry.pack(pady=8)
            self.reg_entries[key] = entry

        # Register button
        register_btn = ctk.CTkButton(
            form_frame,
            text="CREATE ACCOUNT",
            command=self.register_with_validated_license,
            width=300,
            height=45,
            font=ctk.CTkFont(size=14, weight="bold"),
            fg_color="#00ff88",
            hover_color="#00cc66"
        )
        register_btn.pack(pady=20)

        # Back button
        back_btn = ctk.CTkButton(
            form_frame,
            text="‚Üê BACK",
            command=self.show_license_activation,
            width=300,
            height=35,
            fg_color="transparent",
            font=ctk.CTkFont(size=12),
            text_color="#888888"
        )
        back_btn.pack(pady=5)

    def register_with_validated_license(self):
        """Handle registration with pre-validated license - CORRIGIDO"""
        data = {}
        for key, entry in self.reg_entries.items():
            data[key] = entry.get().strip()

        # Validation
        if not all(data.values()):
            messagebox.showerror("Error", "All fields are required")
            return

        if data['password'] != data['confirm_password']:
            messagebox.showerror("Error", "Passwords do not match")
            return

        if len(data['password']) < 6:
            messagebox.showerror("Error", "Password must be at least 6 characters")
            return

        # Use the pre-validated license key
        license_key = self.validated_license

        # DEBUG: Verificar exist√™ncia antes de registrar
        print("=== DEBUG REGISTRO ===")
        print(f"Username: {data['username']}")
        print(f"Email: {data['email']}")
        print(f"License: {license_key}")

        # Verifica exist√™ncia antes de registrar
        check_result = self.auth.check_user_exists(data['username'], data['email'])
        print(f"Check result: {check_result}")

        # Attempt registration
        success = self.auth.register_user(data['username'], data['email'], data['password'], license_key)
        print(f"Resultado registro: {success}")

        if success:
            messagebox.showinfo("Success", "Account created successfully! You can now login.")

            # CORRE√á√ÉO: Redirecionar para login e preencher email
            self.show_login()
            self.username_entry.delete(0, 'end')
            self.username_entry.insert(0, data['email'])
            self.password_entry.focus_set()

        else:
            # Mensagem mais espec√≠fica baseada na verifica√ß√£o
            if check_result['email_exists'] and check_result['username_exists']:
                error_msg = "Both email and username are already registered"
            elif check_result['email_exists']:
                error_msg = "Email is already registered"
            elif check_result['username_exists']:
                error_msg = "Username is already taken"
            else:
                error_msg = "Unable to create account. Possible reasons:\n" \
                           "‚Ä¢ Email already registered\n" \
                           "‚Ä¢ Username already taken\n" \
                           "‚Ä¢ License key already used\n" \
                           "‚Ä¢ Network connection issue"

            messagebox.showerror("Registration Failed", error_msg)

    def activate_license(self):
        """Handle license activation (legacy method)"""
        license_key = self.license_entry.get().strip()

        if not license_key:
            messagebox.showerror("Error", "Please enter a license key")
            return

        if self.auth.validate_license(license_key):
            messagebox.showinfo("Success", "License is valid and available for registration")
        else:
            messagebox.showerror("Error", "License key is invalid or already in use")

    def start_main_app(self):
        """Start the main Midnight Spoofer application"""
        try:
            from dashboard.dashboard import MidnightSpooferGUI
            from controllers.spoofer_controller import SpoofingController
            from cleaners.system_cleaner import SystemCleaner
            from utils.hardware_reader import HardwareReader
            from utils.logger import logger
            from spoofers.mac_spoofer.mac_spoofer import MACSpoofer
            from spoofers.hwid_spoofer.hwid_spoofer import HWIDSpoofer
            from spoofers.guid_spoofer.guid_spoofer import GUIDSpoofer

            # Initialize all core components
            cleaner = SystemCleaner()
            hw_reader = HardwareReader()
            mac_spoofer = MACSpoofer()
            hwid_spoofer = HWIDSpoofer()
            guid_spoofer = GUIDSpoofer()

            # Initialize controller
            spoofer_controller = SpoofingController(
                cleaner=cleaner,
                mac_spoofer=mac_spoofer,
                hwid_spoofer=hwid_spoofer,
                guid_spoofer=guid_spoofer,
                hw_reader=hw_reader
            )

            # Start main GUI
            app = MidnightSpooferGUI(spoofer_controller, icon_path=self.icon_path)
            app.run()

        except Exception as e:
            messagebox.showerror("Error", f"Failed to start main application: {str(e)}")
            sys.exit(1)

    def run(self):
        """Start the login application"""
        self.window.mainloop()


# legacy\src\cleaners\system_cleaner.py

# src/cleaners/system_cleaner.py

import os
import shutil
import subprocess
import winreg
import tempfile
import glob
from pathlib import Path
import psutil
import random
import string
import time
from datetime import datetime
from utils.logger import logger
from .system_paths import (
    PROCESSES_TO_KILL,
    FIVEM_PATHS,
    DISCORD_PATHS,
    SYSTEM_TEMP_PATHS,
    BROWSER_CACHE_PATHS,
    REGISTRY_CLEANING_PATHS,
    DISCORD_CACHE_PATHS,
    DISCORD_STORAGE_PATHS
)

class SystemCleaner:
    def __init__(self):
        self.total_operations = 0
        self.completed_operations = 0
        self.processes_to_kill = PROCESSES_TO_KILL
        self.fivem_paths = FIVEM_PATHS
        self.discord_paths = DISCORD_PATHS
        self.system_temp_paths = SYSTEM_TEMP_PATHS
        self.browser_cache_paths = BROWSER_CACHE_PATHS
        self.registry_cleaning_paths = REGISTRY_CLEANING_PATHS
        self.discord_cache_paths = DISCORD_CACHE_PATHS
        self.discord_storage_paths = DISCORD_STORAGE_PATHS

    def get_progress(self):
        """Calculate current progress percentage"""
        if self.total_operations == 0:
            return 0
        return (self.completed_operations / self.total_operations) * 100

    def timed_operation(self, operation_name, operation_func):
        """Execute operation with timing and logging"""
        start_time = time.time()
        logger.info(f"Starting: {operation_name}", context="CLEANER")
        
        try:
            result = operation_func()
            elapsed_time = time.time() - start_time
            logger.success(f"{operation_name} - Done in {elapsed_time:.2f}s", context="CLEANER")
            return result
        except Exception as e:
            elapsed_time = time.time() - start_time
            logger.error(f"{operation_name} - Failed after {elapsed_time:.2f}s: {str(e)}", context="CLEANER")
            raise
    
    def kill_target_processes(self):
        """Kill target processes with better detection"""
        def _kill():
            killed = 0
            
            # First pass - normal kill
            for proc in psutil.process_iter(['name', 'pid']):
                try:
                    proc_name = proc.info['name'].lower() if proc.info['name'] else ''
                    for target in self.processes_to_kill:
                        if target in proc_name:
                            try:
                                proc.kill()
                                proc.wait(timeout=3)  # Wait for termination
                                killed += 1
                                logger.info(f"Killed: {proc.info['name']} (PID: {proc.info['pid']})", context="TERMINATE")
                                break
                            except (psutil.NoSuchProcess, psutil.TimeoutExpired):
                                # Process already dead or stuck
                                continue
                except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):
                    continue
            
            # Second pass - force kill stubborn processes
            time.sleep(1)  # Let system process kills
            for proc in psutil.process_iter(['name']):
                try:
                    proc_name = proc.info['name'].lower() if proc.info['name'] else ''
                    for target in self.processes_to_kill:
                        if target in proc_name:
                            try:
                                proc.kill()
                                killed += 1
                                logger.warning(f"Forcefully terminated: {proc.info['name']}", context="TERMINATE")
                            except:
                                continue
                except:
                    continue
            
            logger.info(f"{killed} processes terminated", context="STATUS")
            return killed > 0
        
        return self.timed_operation("Process Termination", _kill)
    
    def clean_fivem_cache(self):
        """Clean FiveM cache but keep important files"""
        def _clean():
            # Files we DON'T want to delete
            FILE_BLACKLIST = [
                'fivem.exe',
                'fiveguard.exe', 
                'fxserver.exe',
                'fivem.app',
                'fivem',
                'citizenfx.exe'
            ]
            
            cleaned_count = 0
            for path in self.fivem_paths:
                if os.path.exists(path):
                    try:
                        shutil.rmtree(path, ignore_errors=True)
                        cleaned_count += 1
                        logger.info(f"Purged directory: {os.path.basename(path)}", context="CLEAN")
                    except Exception as e:
                        logger.warning(f"Failed to delete {path}: {str(e)}", context="CLEAN")
            
            # Clean specific file types but skip blacklisted files
            fivem_app_path = os.path.join(os.environ['LOCALAPPDATA'], 'FiveM', 'FiveM.app')
            if os.path.exists(fivem_app_path):
                try:
                    # File patterns to clean
                    file_patterns = [
                        '*.bin', '*.dll', '*.ini', '*.xml', '*.log', '*.tmp',
                        'cache*.dat', '*.cfg', '*.json'
                    ]
                    
                    for pattern in file_patterns:
                        for file_path in glob.glob(os.path.join(fivem_app_path, '**', pattern), recursive=True):
                            try:
                                # Check if file is blacklisted
                                filename = os.path.basename(file_path).lower()
                                if any(blacklisted_file in filename for blacklisted_file in FILE_BLACKLIST):
                                    logger.debug(f"Preserved blacklisted file: {filename}", context="BLACKLIST")
                                    continue
                                    
                                os.remove(file_path)
                                cleaned_count += 1
                                logger.info(f"Removed file: {os.path.basename(file_path)}", context="DELETE")
                            except Exception as e:
                                logger.warning(f"Failed to remove {file_path}: {str(e)}", context="DELETE")
                except Exception as e:
                    logger.warning(f"Error scanning FiveM files: {str(e)}", context="CLEAN")
            
            logger.info(f"FiveM cleanup: {cleaned_count} items removed", context="STATUS")
            return cleaned_count > 0
        
        return self.timed_operation("FiveM Cache Purge", _clean)
    
    def spoof_discord_rpc(self):
        """Rename Discord RPC modules to break tracking"""
        def _clean():
            renamed_count = 0
            for base_path in self.discord_paths:
                if os.path.exists(base_path):
                    try:
                        # Find version folders (like 0.0.309)
                        for item in os.listdir(base_path):
                            version_path = os.path.join(base_path, item)
                            
                            # Check if it's a version folder
                            if os.path.isdir(version_path) and any(c.isdigit() for c in item):
                                modules_path = os.path.join(version_path, 'modules')
                                if os.path.exists(modules_path):
                                    for module_item in os.listdir(modules_path):
                                        # Find RPC modules
                                        if 'discord_rpc' in module_item.lower() or 'rpc' in module_item.lower():
                                            old_path = os.path.join(modules_path, module_item)
                                            new_name = f"discord_rpc_{random.randint(10000, 99999)}"
                                            new_path = os.path.join(modules_path, new_name)
                                            try:
                                                if os.path.exists(old_path):
                                                    os.rename(old_path, new_path)
                                                    renamed_count += 1
                                                    logger.info(f"Renamed RPC: {module_item} -> {new_name}", context="MODIFY")
                                            except Exception as e:
                                                logger.warning(f"Failed to rename {module_item}: {str(e)}", context="MODIFY")
                    except Exception as e:
                        logger.error(f"Error in {base_path}: {str(e)}", context="CLEAN")
            
            # Clean Discord caches
            for cache_path in self.discord_cache_paths:
                if os.path.exists(cache_path):
                    try:
                        shutil.rmtree(cache_path, ignore_errors=True)
                        logger.info(f"Cleared cache: {os.path.basename(cache_path)}", context="CLEAN")
                    except Exception as e:
                        logger.warning(f"Failed to clear {cache_path}: {str(e)}", context="CLEAN")
            
            # Clean Discord storage
            for storage_path in self.discord_storage_paths:
                if os.path.exists(storage_path):
                    try:
                        shutil.rmtree(storage_path, ignore_errors=True)
                        logger.info(f"Cleared storage: {os.path.basename(storage_path)}", context="CLEAN")
                    except Exception as e:
                        logger.warning(f"Failed to clear {storage_path}: {str(e)}", context="CLEAN")
            
            logger.info(f"Discord spoofing: {renamed_count} RPC modules modified", context="STATUS")
            return renamed_count > 0
        
        return self.timed_operation("Discord RPC Spoofing", _clean)
    
    def clean_system_temp(self):
        """Clean system temp files safely"""
        def _clean():
            cleaned_count = 0
            for temp_path in self.system_temp_paths:
                if os.path.exists(temp_path):
                    try:
                        # Be careful with system files
                        for item in os.listdir(temp_path):
                            item_path = os.path.join(temp_path, item)
                            try:
                                # Skip system-critical files
                                if not item.startswith('System') and not item in ['Windows', 'system']:
                                    if os.path.isfile(item_path):
                                        os.remove(item_path)
                                        cleaned_count += 1
                                    elif os.path.isdir(item_path):
                                        # Only safe directories
                                        dir_blacklist = ['Windows', 'System', 'Boot']
                                        if not any(blacklisted in item for blacklisted in dir_blacklist):
                                            shutil.rmtree(item_path, ignore_errors=True)
                                            cleaned_count += 1
                            except Exception as e:
                                # Skip problematic files
                                continue
                    except Exception as e:
                        logger.warning(f"Error cleaning {temp_path}: {str(e)}", context="CLEAN")
            
            for browser_path in self.browser_cache_paths:
                if os.path.exists(browser_path):
                    try:
                        shutil.rmtree(browser_path, ignore_errors=True)
                        cleaned_count += 1
                        logger.info(f"Cleared browser cache: {os.path.basename(browser_path)}", context="CLEAN")
                    except Exception as e:
                        logger.warning(f"Failed to clear {browser_path}: {str(e)}", context="CLEAN")
            
            logger.info(f"Temp files: {cleaned_count} items removed", context="CLEAN")
            return cleaned_count > 0
        
        return self.timed_operation("System Temp Cleanup", _clean)
    
    def reset_network(self):
        """Reset network stack and clear caches"""
        def _reset():
            commands = [
                ('DNS Flush', ['ipconfig', '/flushdns']),
                ('Winsock Reset', ['netsh', 'winsock', 'reset']),
                ('IP Reset', ['netsh', 'int', 'ip', 'reset', 'reset.log']),
                ('TCP Reset', ['netsh', 'int', 'tcp', 'set', 'global', 'autotuninglevel=normal']),
                ('Firewall Reset', ['netsh', 'advfirewall', 'reset']),
                ('Proxy Reset', ['netsh', 'winhttp', 'reset', 'proxy']),
            ]
            
            success_count = 0
            for name, cmd in commands:
                try:
                    # Special handling for IP reset
                    if name == 'IP Reset':
                        try:
                            # Run with file output
                            with open('reset.log', 'w') as f:
                                result = subprocess.run(cmd[:-1], stdout=f, stderr=subprocess.PIPE, 
                                                      timeout=30, shell=True, text=True)
                            if os.path.exists('reset.log'):
                                os.remove('reset.log')  # Cleanup log
                            success_count += 1
                            logger.info(f"{name}: Success", context="NETWORK")
                        except Exception as e:
                            logger.warning(f"{name}: Partial - {str(e)}", context="NETWORK")
                    else:
                        result = subprocess.run(cmd, capture_output=True, text=True, timeout=30, shell=True)
                        if result.returncode == 0:
                            success_count += 1
                            logger.info(f"{name}: Success", context="NETWORK")
                        else:
                            # Try alternative method
                            try:
                                alt_result = subprocess.run(cmd, timeout=30, shell=True)
                                if alt_result.returncode == 0:
                                    success_count += 1
                                    logger.info(f"{name}: Success (alt)", context="NETWORK")
                                else:
                                    logger.warning(f"{name}: Failed", context="NETWORK")
                            except:
                                logger.warning(f"{name}: Failed", context="NETWORK")
                except Exception as e:
                    logger.warning(f"{name}: Error - {str(e)}", context="NETWORK")
            
            # Extra network cleanup
            try:
                subprocess.run(['nbtstat', '-R'], capture_output=True, shell=True)
                subprocess.run(['nbtstat', '-RR'], capture_output=True, shell=True)
                logger.info("NetBIOS cache cleared", context="NETWORK")
            except:
                pass
            
            logger.info(f"Network reset: {success_count}/{len(commands)} operations", context="STATUS")
            return success_count >= 3  # Most should work
        
        return self.timed_operation("Network Stack Reset", _reset)
    
    def clean_registry_entries(self):
        """Clean registry entries safely"""
        def _clean():
            cleaned_count = 0
            
            # Try reg.exe first (better permissions)
            for key_path, hive_str in self.registry_cleaning_paths:
                try:
                    # Convert hive for reg.exe
                    if hive_str == 'HKEY_CURRENT_USER':
                        reg_hive = "HKCU"
                        hive = winreg.HKEY_CURRENT_USER
                    else:
                        continue # Add other hives later if needed
                    
                    # Try reg.exe deletion
                    cmd = ['reg', 'delete', f"{reg_hive}\\{key_path}", '/f']
                    result = subprocess.run(cmd, capture_output=True, text=True, timeout=10, shell=True)
                    
                    if result.returncode == 0:
                        cleaned_count += 1
                        logger.info(f"Deleted key: {key_path}", context="REGISTRY")
                    else:
                        # Fallback to Python method
                        try:
                            # Check if key exists
                            try:
                                key = winreg.OpenKey(hive, key_path, 0, winreg.KEY_READ)
                                winreg.CloseKey(key)
                                
                                # Try to delete
                                try:
                                    winreg.DeleteKey(hive, key_path)
                                    cleaned_count += 1
                                    logger.info(f"Cleaned key: {key_path}", context="REGISTRY")
                                except PermissionError:
                                    # Try recursive deletion
                                    try:
                                        key = winreg.OpenKey(hive, key_path, 0, winreg.KEY_ALL_ACCESS)
                                        # Delete subkeys first
                                        try:
                                            i = 0
                                            while True:
                                                try:
                                                    subkey_name = winreg.EnumKey(key, i)
                                                    winreg.DeleteKey(key, subkey_name)
                                                    i += 1
                                                except WindowsError:
                                                    break
                                            winreg.CloseKey(key)
                                            winreg.DeleteKey(hive, key_path)
                                            cleaned_count += 1
                                            logger.info(f"Recursively cleaned key: {key_path}", context="REGISTRY")
                                        except:
                                            logger.warning(f"Complex recursive delete failed for: {key_path}", context="REGISTRY")
                                    except:
                                        logger.warning(f"Permission denied for key: {key_path}", context="REGISTRY")
                            except FileNotFoundError:
                                logger.debug(f"Registry key not found: {key_path}", context="REGISTRY")
                        except Exception as e:
                            logger.warning(f"Failed to clean {key_path}: {str(e)}", context="REGISTRY")
                except Exception as e:
                    logger.error(f"Registry error for {key_path}: {str(e)}", context="REGISTRY")
            
            # Extra cleanup for stubborn keys
            stubborn_keys = [
                r"HKCU\Software\CitizenFX",
                r"HKCU\Software\FiveM", 
                r"HKCU\Software\Rockstar Games",
            ]
            
            for key in stubborn_keys:
                try:
                    # Multiple deletion methods
                    methods = [
                        ['reg', 'delete', key, '/f', '/va'],
                        ['reg', 'delete', key, '/f'],
                    ]
                    
                    for cmd in methods:
                        result = subprocess.run(cmd, capture_output=True, timeout=5, shell=True)
                        if result.returncode == 0:
                            cleaned_count += 1
                            logger.info(f"Removed stubborn key: {key}", context="REGISTRY")
                            break
                except:
                    continue
            
            logger.info(f"Registry cleanup: {cleaned_count} entries", context="STATUS")
            return cleaned_count > 0
        
        return self.timed_operation("Registry Cleanup", _clean)
    
    def execute_real_spoofing(self):
        """Main method - execute full spoofing routine"""
        start_time = time.time()
        logger.info("=" * 60, context="SPOOFING")
        logger.info("STARTING SPOOFING PROTOCOL", context="SPOOFING")
        logger.info("Performing ACTUAL system modifications", context="SPOOFING")
        logger.info("=" * 60, context="SPOOFING")
        
        # Operations in optimal order
        operations = [
            ("Killing processes", self.kill_target_processes),
            ("Cleaning temp files", self.clean_system_temp),
            ("Spoofing Discord", self.spoof_discord_rpc),
            ("Cleaning FiveM", self.clean_fivem_cache),
            ("Cleaning registry", self.clean_registry_entries),
            ("Resetting network", self.reset_network),
        ]
        
        self.total_operations = len(operations)
        self.completed_operations = 0
        
        results = []
        for op_name, op_function in operations:
            logger.info(f"Running: {op_name}", context="SPOOFING")
            try:
                result = op_function()
                results.append(result)
                self.completed_operations += 1
                progress = self.get_progress()
                logger.info(f"Progress: {self.completed_operations}/{self.total_operations} ({progress:.1f}%)", context="SPOOFING")
            except Exception as e:
                logger.error(f"{op_name} failed: {str(e)}", context="SPOOFING")
                results.append(False)
        
        success_count = sum(1 for r in results if r)
        total_time = time.time() - start_time
        
        logger.info("=" * 60, context="SPOOFING")
        logger.info(f"SPOOFING COMPLETE: {success_count}/{self.total_operations} operations successful", context="SPOOFING")
        logger.info(f"Total time: {total_time:.2f}s", context="STATS")
        
        if success_count >= 4:  # Most operations successful
            logger.success("‚úÖ SPOOFING SUCCESSFUL!", context="SPOOFING")
            logger.info("Discord RPC modified", context="SPOOFING")
            logger.info("FiveM cache cleared", context="SPOOFING")
            logger.info("System identity spoofed", context="SPOOFING")
        else:
            logger.warning("‚ö†Ô∏è Partial success - some operations failed", context="SPOOFING")
        
        logger.info("=" * 60, context="SPOOFING")
        
        return success_count >= 4


# legacy\src\cleaners\system_paths.py

"""
System cleaning paths and configurations
"""
import os

PROCESSES_TO_KILL = [
    'discord', 'fivem', 'steam', 'steamwebhelper',
    'epicgameslauncher', 'socialclub', 'rockstargames'
]

FIVEM_PATHS = [
    os.path.join(os.environ['LOCALAPPDATA'], 'FiveM', 'FiveM.app', 'cache'),
    os.path.join(os.environ['LOCALAPPDATA'], 'FiveM', 'FiveM.app', 'logs'),
    os.path.join(os.environ['LOCALAPPDATA'], 'FiveM', 'FiveM.app', 'crashes'),
    os.path.join(os.environ['LOCALAPPDATA'], 'DigitalEntitlements'),
    os.path.join(os.environ['APPDATA'], 'CitizenFX'),
    os.path.join(os.environ['LOCALAPPDATA'], 'FiveM', 'FiveM.app', 'data', 'cache'),
    os.path.join(os.environ['LOCALAPPDATA'], 'FiveM', 'FiveM.app', 'browser'),
    os.path.join(os.environ['USERPROFILE'], 'AppData', 'Roaming', 'CitizenFX'),
    os.path.join(os.environ['USERPROFILE'], 'Documents', 'Rockstar Games'),
]

SYSTEM_TEMP_PATHS = [
    os.environ.get('TEMP', ''),
    os.environ.get('TMP', ''),
    os.path.join(os.environ['LOCALAPPDATA'], 'Temp'),
    r'C:\Windows\Temp',
    os.path.join(os.environ['USERPROFILE'], 'AppData', 'Local', 'Temp'),
]

BROWSER_CACHE_PATHS = [
    os.path.join(os.environ['LOCALAPPDATA'], 'Google', 'Chrome', 'User Data', 'Default', 'Cache'),
    os.path.join(os.environ['LOCALAPPDATA'], 'Microsoft', 'Edge', 'User Data', 'Default', 'Cache'),
    os.path.join(os.environ['APPDATA'], 'Mozilla', 'Firefox', 'Profiles'),
]

REGISTRY_CLEANING_PATHS = [
    (r'Software\CitizenFX', 'HKEY_CURRENT_USER'),
    (r'Software\FiveM', 'HKEY_CURRENT_USER'),
    (r'Software\Rockstar Games', 'HKEY_CURRENT_USER'),
    (r'Software\Valve\Steam', 'HKEY_CURRENT_USER'),
    (r'Software\Rockstar Games Launcher', 'HKEY_CURRENT_USER'),
    (r'Software\Epic Games', 'HKEY_CURRENT_USER'),
]

DISCORD_PATHS = [
    os.path.join(os.environ['APPDATA'], 'discord'),
    os.path.join(os.environ['LOCALAPPDATA'], 'Discord'),
    os.path.join(os.environ['LOCALAPPDATA'], 'DiscordCanary'),
    os.path.join(os.environ['LOCALAPPDATA'], 'DiscordPTB'),
]

DISCORD_CACHE_PATHS = [
    os.path.join(os.environ['LOCALAPPDATA'], 'Discord', 'Cache'),
    os.path.join(os.environ['LOCALAPPDATA'], 'DiscordCanary', 'Cache'),
    os.path.join(os.environ['LOCALAPPDATA'], 'DiscordPTB', 'Cache'),
    os.path.join(os.environ['LOCALAPPDATA'], 'Discord', 'Code Cache'),
    os.path.join(os.environ['LOCALAPPDATA'], 'Discord', 'GPUCache'),
]

DISCORD_STORAGE_PATHS = [
    os.path.join(os.environ['LOCALAPPDATA'], 'Discord', 'Local Storage'),
    os.path.join(os.environ['LOCALAPPDATA'], 'DiscordCanary', 'Local Storage'),
    os.path.join(os.environ['LOCALAPPDATA'], 'DiscordPTB', 'Local Storage'),
]


# legacy\src\controllers\spoofer_controller.py

# src/controllers/spoofer_controller.py

import threading
from datetime import datetime
import psutil
from utils.logger import logger

class SpoofingController:
    def __init__(self, cleaner, mac_spoofer, hwid_spoofer, guid_spoofer, hw_reader):
        self.cleaner = cleaner
        self.mac_spoofer = mac_spoofer
        self.hwid_spoofer = hwid_spoofer
        self.guid_spoofer = guid_spoofer
        self.hw_reader = hw_reader
        self.ui_callbacks = {}  # Will be set by the GUI
        self.last_spoof_time = None

    def set_ui_callbacks(self, callbacks):
        """Allows the GUI to register its callbacks with the controller."""
        self.ui_callbacks = callbacks

    def check_discord_process(self):
        """Verifica e encerra processos do Discord corretamente"""
        discord_processes = ["discord.exe", "discordptb.exe", "discordcanary.exe"]
        processes_found = []

        for proc in psutil.process_iter(['name']):
            try:
                if proc.info['name'] and proc.info['name'].lower() in discord_processes:
                    processes_found.append(proc)
            except (psutil.NoSuchProcess, psutil.AccessDenied):
                continue

        if processes_found:
            logger.log_info(f"Found {len(processes_found)} Discord process(es), terminating...", "DISCORD")
            for process in processes_found:
                try:
                    process.terminate()
                    process.wait(timeout=5)  # Wait for process to terminate
                    logger.log_success(f"Terminated: {process.name()}", "DISCORD")
                except Exception as e:
                    logger.log_warning(f"Failed to terminate {process.name()}: {str(e)}", "DISCORD")
            return True
        else:
            logger.log_info("Discord is not running (this is OK)", "DISCORD")
            return True  # ‚Üê MUDAN√áA CR√çTICA: Retorna True mesmo quando n√£o encontrado

    def start_spoofing_thread(self, toggle_states, selected_interface, selected_vendor, selected_mac):
        """Inicia a sequ√™ncia de spoofing em uma nova thread."""
        thread = threading.Thread(
            target=self.execute_spoofing,
            args=(toggle_states, selected_interface, selected_vendor, selected_mac),
            daemon=True
        )
        thread.start()

    def execute_spoofing(self, toggle_states, selected_interface, selected_vendor, selected_mac):
        """Executa a l√≥gica de spoofing CORRIGIDA"""
        try:
            logger.log_info("üöÄ INICIANDO SPOOFING COMPLETO", "SPOOFING")

            # 1. Primeiro executar limpeza
            cleaner_success = self.cleaner.execute_real_spoofing()

            # 2. Executar MAC spoofing SE habilitado
            mac_success = False
            if toggle_states.get("MAC SPOOFING") and self.mac_spoofer and selected_interface:
                logger.log_info("Executando MAC spoofing...", "MAC")
                mac_success = self.mac_spoofer.spoof_mac_address(
                    selected_interface,
                    selected_vendor,
                    selected_mac
                )

            # 3. Executar GUID spoofing SE habilitado
            guid_success = False
            if toggle_states.get("GUID SPOOFING") and self.guid_spoofer:
                logger.log_info("Executando GUID spoofing...", "GUID")
                guid_success = self.guid_spoofer.spoof_guid()

            # 4. Executar HWID spoofing SE habilitado
            hwid_success = False
            if toggle_states.get("HWID SPOOFER") and self.hwid_spoofer:
                logger.log_info("Executando HWID spoofing...", "HWID")
                hwid_success = self.hwid_spoofer.spoof_hwid()

            # Verificar resultados
            success_count = sum([cleaner_success, mac_success, guid_success, hwid_success])
            total_operations = sum([1,  # cleaner sempre executa
                                  int(toggle_states.get("MAC SPOOFING", False)),
                                  int(toggle_states.get("GUID SPOOFING", False)),
                                  int(toggle_states.get("HWID SPOOFER", False))])

            if success_count >= total_operations * 0.7:  # 70% de sucesso
                self.last_spoof_time = datetime.now()
                if 'on_success' in self.ui_callbacks:
                    self.ui_callbacks['on_success']()
                logger.log_success(f"‚úÖ SPOOFING COMPLETO: {success_count}/{total_operations} opera√ß√µes", "SUCCESS")
                return True
            else:
                if 'on_failure' in self.ui_callbacks:
                    self.ui_callbacks['on_failure'](f"Apenas {success_count}/{total_operations} opera√ß√µes")
                logger.log_warning(f"‚ö†Ô∏è SPOOFING PARCIAL: {success_count}/{total_operations} opera√ß√µes", "WARNING")
                return False

        except Exception as e:
            logger.log_error(f"‚ùå SPOOFING FALHOU: {str(e)}", "CRITICAL")
            if 'on_failure' in self.ui_callbacks:
                self.ui_callbacks['on_failure']("Falha cr√≠tica")
            return False


# legacy\src\dashboard\dashboard.py

# src/dashboard/dashboard.py

import customtkinter as ctk
import threading
import time
import queue
from datetime import datetime
import os
import sys

sys.path.append(os.path.join(os.path.dirname(__file__), '..'))

from cleaners.system_cleaner import SystemCleaner
from utils.hardware_reader import HardwareReader
from utils.logger import logger
from utils.icon_manager import IconManager
from spoofers.mac_spoofer.mac_spoofer import MACSpoofer
from spoofers.mac_spoofer.select_network import InterfaceSelectionDialog
from .components.particles import ParticleSystem
from .components.buttons import AnimatedButton
from .components.progress import CircularProgress
from .components.toast import ToastNotification
from .components.stats import SystemStats
from controllers.spoofer_controller import SpoofingController


class MidnightSpooferGUI:
    def __init__(self, spoofer_controller, icon_path=None):
        self.root = ctk.CTk()
        self.root.title("Midnight Spoofer Beta")
        self.root.geometry("1400x900")
        self.root.resizable(True, True)
        self.root.configure(fg_color="#0a0a1a")

        self.icon_path = icon_path
        self.center_window()

        # Set icon immediately and with delays
        self.set_window_icon()
        
        self.controller = spoofer_controller
        
        # Register GUI as logger subscriber
        logger.add_subscriber(self.add_log_ui)
        
        # Define and register UI callbacks with the controller
        ui_callbacks = {
            'on_start': self.handle_spoofing_start,
            'on_success': self.handle_spoofing_success,
            'on_failure': self.handle_spoofing_failure,
            'on_finish': self.handle_spoofing_finish,
        }
        self.controller.set_ui_callbacks(ui_callbacks)
        
        self.cleaning_in_progress = False
        self.sidebar_expanded = True
        self.current_theme = "purple"
        self.last_spoof_time = None
        
        self.toggle_states = {
            "MAC SPOOFING": False,
            "GUID SPOOFING": False,
            "HWID SPOOFER": False,
            "EFI SPOOFER": False,
            "RESET TPM": False,
            "ENABLE VPN": False
        }
        # Stored MAC selection (deferred until Start Spoofing)
        self.selected_interface = None
        self.selected_vendor = None
        self.selected_mac = None

        # Inicializar dicion√°rio de frames das abas
        self.tab_frames = {}
        self.current_tab = "HARDWARE"

        self.setup_ui()
        self.update_system_stats()

        # Use logger instead of direct UI calls
        logger.log_info("Midnight Spoofer Premium INITIALIZED", "SYSTEM")
        logger.log_info("Spoofing engine loaded", "SECURITY")
        logger.log_success("Discord/FiveM spoofing ready", "READY")
        logger.log_warning("Run as Administrator for full functionality", "INFO")
        logger.log_info("MAC Spoofer module loaded", "MAC")

        # Move hardware initialization logs to after UI is fully set up
        if self.controller.hw_reader:
            logger.log_info("Hardware reader initialized successfully", "HARDWARE")
        else:
            logger.log_warning("Hardware reader failed - using fallback data", "HARDWARE")

        # Schedule initial data loading after UI is fully set up
        self.root.after(100, self.initial_data_load)

    def initial_data_load(self):
        """Carregamento inicial simplificado - sem pressa"""
        try:
            logger.log_info("Starting initial data loading...", "SYSTEM")

            # Apenas agenda o carregamento para depois da UI estar totalmente pronta
            self.root.after(500, self._load_initial_data)

        except Exception as e:
            logger.log_error(f"Error scheduling initial load: {str(e)}", "SYSTEM")

    def _load_initial_data(self):
        """Carrega dados iniciais de forma ass√≠ncrona"""
        try:
            if not self.controller.hw_reader:
                logger.log_warning("Hardware reader not available", "HARDWARE")
                self._set_all_na_states()
                return

            # Carrega hardware
            hw_data = self.controller.hw_reader.get_formatted_hardware_data(self.controller.mac_spoofer)
            if hw_data:
                hardware_mapping = {
                    "Disk C:": hw_data.get('disk_c', 'N/A'),
                    "Disk D:": hw_data.get('disk_d', 'N/A'),
                    "Motherboard:": hw_data.get('motherboard', 'N/A'),
                    "Chassis:": hw_data.get('chassis', 'N/A'),
                    "Bios:": hw_data.get('bios', 'N/A'),
                    "CPU:": hw_data.get('cpu', 'N/A'),
                    "MAC:": hw_data.get('mac', 'N/A'),
                    "UUID:": hw_data.get('smbios_uuid', 'N/A')
                }
                self.update_hardware_tab(hardware_mapping)
            else:
                self._set_hardware_na_states()

            # Carrega software
            sw_data = self.controller.hw_reader.get_software_identifiers()
            if sw_data:
                software_mapping = {
                    "Machine GUID:": sw_data.get('machine_guid', 'N/A'),
                    "FiveM GUID:": sw_data.get('fivem_guid', 'N/A'),
                    "Rockstar GUID:": sw_data.get('rockstar_guid', 'N/A'),
                    "Product ID:": sw_data.get('product_id', 'N/A'),
                    "Installation ID:": sw_data.get('installation_id', 'N/A'),
                    "Windows Activation:": sw_data.get('windows_activation', 'N/A')
                }
                self.update_software_tab(software_mapping)
            else:
                self._set_software_na_states()

            self.initial_load_complete = True
            logger.log_success("Initial data loading completed", "SYSTEM")

        except Exception as e:
            logger.log_error(f"Error in initial data load: {str(e)}", "SYSTEM")
            self._set_all_na_states()

    def _set_loading_states(self):
        """Set all labels to loading state"""
        try:
            # Hardware loading states
            if hasattr(self, 'hardware_labels'):
                for label_text in self.hardware_labels:
                    if label_text in self.hardware_labels and self.hardware_labels[label_text].winfo_exists():
                        self.hardware_labels[label_text].configure(text="Loading...", text_color="#ffaa00")

            # Software loading states
            if hasattr(self, 'software_labels'):
                for label_text in self.software_labels:
                    if label_text in self.software_labels and self.software_labels[label_text].winfo_exists():
                        self.software_labels[label_text].configure(text="Loading...", text_color="#ffaa00")

        except Exception as e:
            logger.log_error(f"Error setting loading states: {str(e)}", "UI")

    def _set_all_na_states(self):
        """Define todos os estados como N/A em caso de erro"""
        self._set_hardware_na_states()
        self._set_software_na_states()

    def _set_hardware_na_states(self):
        """Define estados N/A para hardware"""
        if hasattr(self, 'hardware_labels'):
            for label_text in self.hardware_labels:
                if label_text in self.hardware_labels and self.hardware_labels[label_text].winfo_exists():
                    self.hardware_labels[label_text].configure(text="N/A", text_color="#888888")

    def _set_software_na_states(self):
        """Define estados N/A para software"""
        if hasattr(self, 'software_labels'):
            for label_text in self.software_labels:
                if label_text in self.software_labels and self.software_labels[label_text].winfo_exists():
                    self.software_labels[label_text].configure(text="N/A", text_color="#888888")



    def center_window(self):
        self.root.update_idletasks()
        width = self.root.winfo_width()
        height = self.root.winfo_height()
        x = (self.root.winfo_screenwidth() // 2) - (width // 2)
        y = (self.root.winfo_screenheight() // 2) - (height // 2)
        self.root.geometry(f'{width}x{height}+{x}+{y}')

    def set_window_icon(self):
        """Set window icon with multiple strategies"""
        if not self.icon_path or not os.path.exists(self.icon_path):
            logger.log_warning("Icon path not available for main window", "UI")
            return

        try:
            # Immediate attempt
            self._set_icon_immediate()

            # Delayed attempts for when window is fully ready
            delayed_attempts = [100, 500, 1000, 2000]
            for delay in delayed_attempts:
                self.root.after(delay, self._set_icon_delayed)

        except Exception as e:
            logger.log_error(f"Main window icon setup failed: {str(e)}", "UI")

    def _set_icon_immediate(self):
        """Immediate icon setting attempt"""
        try:
            self.root.iconbitmap(self.icon_path)
            logger.log_info("Main window icon set (immediate)", "UI")
        except Exception as e:
            logger.log_error(f"Immediate icon set failed: {str(e)}", "UI")

    def _set_icon_delayed(self):
        """Delayed icon setting attempts"""
        try:
            if hasattr(self, 'root') and self.root.winfo_exists():
                self.root.iconbitmap(self.icon_path)

                # Also try Windows API
                self._set_icon_windows_api()

        except Exception as e:
            logger.log_error(f"Delayed icon set failed: {str(e)}", "UI")

    def _set_icon_windows_api(self):
        """Windows API method for taskbar icon"""
        try:
            if os.name == 'nt':
                import ctypes
                from ctypes import wintypes

                # Get window handle
                hwnd = ctypes.windll.user32.GetParent(self.root.winfo_id())

                # Force window to appear in taskbar
                GWL_EXSTYLE = -20
                WS_EX_APPWINDOW = 0x00040000
                style = ctypes.windll.user32.GetWindowLongW(hwnd, GWL_EXSTYLE)
                ctypes.windll.user32.SetWindowLongW(hwnd, GWL_EXSTYLE, style | WS_EX_APPWINDOW)

                # Load and set icon
                ICON_BIG = 1
                LR_LOADFROMFILE = 0x00000010

                icon_handle = ctypes.windll.user32.LoadImageW(
                    0, self.icon_path, 1, 32, 32, LR_LOADFROMFILE
                )

                if icon_handle:
                    WM_SETICON = 0x0080
                    ctypes.windll.user32.SendMessageW(hwnd, WM_SETICON, ICON_BIG, icon_handle)

                    # Also set small icon
                    ICON_SMALL = 0
                    icon_small_handle = ctypes.windll.user32.LoadImageW(
                        0, self.icon_path, 1, 16, 16, LR_LOADFROMFILE
                    )
                    if icon_small_handle:
                        ctypes.windll.user32.SendMessageW(hwnd, WM_SETICON, ICON_SMALL, icon_small_handle)

                    logger.log_info("Main window icon set (Windows API)", "UI")

        except Exception as e:
            logger.log_error(f"Windows API icon set failed: {str(e)}", "UI")

    def force_taskbar_icon(self, icon_path):
        """Force set taskbar icon using Windows API"""
        try:
            if os.name == 'nt':
                import ctypes
                from ctypes import wintypes

                # Obter handle da janela
                hwnd = ctypes.windll.user32.GetParent(self.root.winfo_id())

                # Carregar √≠cone do arquivo
                ICON_BIG = 1
                ICON_SMALL = 0
                LR_LOADFROMFILE = 0x00000010
                LR_DEFAULTSIZE = 0x00000040

                # Carregar √≠cone em diferentes tamanhos
                icon_big = ctypes.windll.user32.LoadImageW(
                    0, icon_path, 1, 0, 0, LR_LOADFROMFILE | LR_DEFAULTSIZE
                )

                icon_small = ctypes.windll.user32.LoadImageW(
                    0, icon_path, 1, 16, 16, LR_LOADFROMFILE
                )

                # Definir os √≠cones
                WM_SETICON = 0x0080
                if icon_big:
                    ctypes.windll.user32.SendMessageW(hwnd, WM_SETICON, ICON_BIG, icon_big)
                if icon_small:
                    ctypes.windll.user32.SendMessageW(hwnd, WM_SETICON, ICON_SMALL, icon_small)

        except Exception as e:
            logger.log_error(f"Failed to force taskbar icon: {str(e)}", "UI")

    def add_log_ui(self, message):
        """Callback method for logger subscription - receives formatted messages"""
        # Check if logs_text exists before trying to use it
        if not hasattr(self, 'logs_text') or self.logs_text is None:
            print(f"LOG (UI not ready): {message}")
            return
            
        # Parse log level from message format: [TIME] [LEVEL] [CONTEXT] Message
        if "[ERROR]" in message:
            tag = "error"
        elif "[SUCCESS]" in message:
            tag = "success"
        elif "[WARNING]" in message:
            tag = "warning"
        elif "[SYSTEM]" in message or "[STATUS]" in message or "[INFO]" in message:
            tag = "system"
        elif "[HARDWARE]" in message or "[SECURITY]" in message:
            tag = "hardware"
        elif "[MAC]" in message:  # ‚Üê ADICIONADO: Tag espec√≠fica para logs MAC
            tag = "mac"
        else:
            tag = "info"
        
        self.logs_text.configure(state="normal")
        self.logs_text.insert("end", f"{message}\n", tag)
        self.logs_text.see("end")
        self.logs_text.configure(state="disabled")

    def setup_ui(self):
        self.root.grid_rowconfigure(0, weight=1)
        self.root.grid_columnconfigure(1, weight=1)
        
        self.setup_sidebar()
        
        self.main_content = ctk.CTkFrame(self.root, fg_color="transparent")
        self.main_content.grid(row=0, column=1, sticky="nsew", padx=20, pady=20)
        self.main_content.grid_columnconfigure(0, weight=1)
        self.main_content.grid_rowconfigure(1, weight=1)
        
        self.setup_header()
        self.setup_dashboard()
        self.setup_log_highlighting()

    def setup_sidebar(self):
        self.sidebar = ctk.CTkFrame(self.root, fg_color="#1a1a2e", width=280, corner_radius=0)
        self.sidebar.grid(row=0, column=0, sticky="nsew")
        self.sidebar.grid_propagate(False)
        
        sidebar_content = ctk.CTkFrame(self.sidebar, fg_color="transparent")
        sidebar_content.pack(fill="both", expand=True, padx=20, pady=20)
        
        logo_frame = ctk.CTkFrame(sidebar_content, fg_color="transparent")
        logo_frame.pack(fill="x", pady=(0, 30))
        
        logo_label = ctk.CTkLabel(logo_frame, text="MIDNIGHT",
                                 font=ctk.CTkFont(family="Segoe UI", size=24, weight="bold"),
                                 text_color="#6b21ff")
        logo_label.pack(side="left")
        
        nav_buttons = [
            ("Dashboard", self.show_dashboard),
            ("Spoof Tools", self.show_spoof_tools),
            ("History", self.show_history),
            ("Settings", self.show_settings),
            ("About", self.show_about)
        ]
        
        for text, command in nav_buttons:
            btn = ctk.CTkButton(sidebar_content, text=text, command=command,
                               fg_color="transparent", hover_color="#2d1152",
                               anchor="w", height=45,
                               font=ctk.CTkFont(size=14))
            btn.pack(fill="x", pady=5)
        
        theme_frame = ctk.CTkFrame(sidebar_content, fg_color="transparent")
        theme_frame.pack(side="bottom", fill="x", pady=20)
        
        ctk.CTkLabel(theme_frame, text="THEME", font=ctk.CTkFont(weight="bold")).pack(anchor="w")
        
        theme_options = ctk.CTkSegmentedButton(theme_frame, values=["Purple", "Cyan", "Red"],
                                              command=self.switch_theme)
        theme_options.pack(fill="x", pady=5)
        theme_options.set("Purple")

    def setup_header(self):
        header_frame = ctk.CTkFrame(self.main_content, fg_color="transparent", height=120)
        header_frame.grid(row=0, column=0, sticky="ew", pady=(0, 20))
        header_frame.grid_propagate(False)
        header_frame.grid_columnconfigure((0, 1, 2, 3), weight=1)
        
        self.cpu_card = self.create_stat_card(header_frame, "CPU", "0%", 0, "#6b21ff")
        self.cpu_card.grid(row=0, column=0, padx=(0, 10), sticky="ew")
        
        self.memory_card = self.create_stat_card(header_frame, "Memory", "0%", 1, "#00ff88")
        self.memory_card.grid(row=0, column=1, padx=5, sticky="ew")
        
        self.disk_card = self.create_stat_card(header_frame, "Disk", "0%", 2, "#ffaa00")
        self.disk_card.grid(row=0, column=2, padx=5, sticky="ew")
        
        self.status_card = self.create_status_card(header_frame)
        self.status_card.grid(row=0, column=3, padx=(10, 0), sticky="ew")

    def create_stat_card(self, parent, title, value, column, color):
        card = ctk.CTkFrame(parent, fg_color="#1a1a2e", corner_radius=15)
        
        title_label = ctk.CTkLabel(card, text=title, text_color="#b0b0ff",
                                  font=ctk.CTkFont(size=12))
        title_label.pack(anchor="w", padx=15, pady=(15, 5))
        
        value_label = ctk.CTkLabel(card, text=value, text_color="white",
                                  font=ctk.CTkFont(size=18, weight="bold"))
        value_label.pack(anchor="w", padx=15, pady=(0, 10))
        
        progress = ctk.CTkProgressBar(card, height=4, fg_color="#1a1a2e",
                                     progress_color=color)
        progress.pack(fill="x", padx=15, pady=(0, 10))
        progress.set(0)
        
        return card

    def create_status_card(self, parent):
        card = ctk.CTkFrame(parent, fg_color="#1a1a2e", corner_radius=15)
        
        title_label = ctk.CTkLabel(card, text="STATUS", text_color="#b0b0ff",
                                  font=ctk.CTkFont(size=12))
        title_label.pack(anchor="w", padx=15, pady=(15, 5))
        
        content_frame = ctk.CTkFrame(card, fg_color="transparent")
        content_frame.pack(fill="both", expand=True, padx=15, pady=10)
        
        self.status_dot = ctk.CTkLabel(content_frame, text="‚óè", text_color="#00ff88",
                                      font=ctk.CTkFont(size=20))
        self.status_dot.pack(side="left", padx=(0, 10))
        
        self.status_text = ctk.CTkLabel(content_frame, text="System Ready", text_color="white",
                                       font=ctk.CTkFont(size=14, weight="bold"))
        self.status_text.pack(side="left", fill="both", expand=True)
        
        return card

    def setup_dashboard(self):
        content_frame = ctk.CTkFrame(self.main_content, fg_color="transparent")
        content_frame.grid(row=1, column=0, sticky="nsew")
        content_frame.grid_columnconfigure(0, weight=1)
        content_frame.grid_rowconfigure(1, weight=1)
        
        action_frame = ctk.CTkFrame(content_frame, fg_color="transparent")
        action_frame.grid(row=0, column=0, sticky="ew", pady=(0, 20))
        
        progress_frame = ctk.CTkFrame(action_frame, fg_color="transparent")
        progress_frame.pack(side="left", padx=(0, 20))
        
        self.circular_progress = CircularProgress(progress_frame, size=200)
        self.circular_progress.pack(pady=20)
        
        self.spoof_button = AnimatedButton(
            progress_frame,
            text="START SPOOFING",
            command=self.start_spoofing_sequence,
            font=ctk.CTkFont(family="Segoe UI", size=18, weight="bold"),
            height=50,
            width=200,
            fg_color="#2d1152",
            hover_color="#4a1c6d",
            text_color="#ffffff",
            corner_radius=25,
            border_width=3,
            border_color="#6b21ff"
        )
        self.spoof_button.pack(pady=(0, 20))
        
        # Container principal dividido em dois containers separados
        self.modules_container = ctk.CTkFrame(action_frame, fg_color="transparent")
        self.modules_container.pack(side="right", fill="both", expand=True)
        
        # Configurar grid com duas colunas de tamanhos iguais
        self.modules_container.grid_columnconfigure(0, weight=1)
        self.modules_container.grid_columnconfigure(1, weight=1)
        self.modules_container.grid_rowconfigure(0, weight=1)
        
        # Criar dois containers separados com bordas distintas
        self.setup_spoofing_modules()
        self.setup_controls()
        
        # Create logs area
        self.setup_logs_area(content_frame)

    def setup_spoofing_modules(self):
        """Configura a se√ß√£o esquerda - Spoofing Modules com abas elegantes"""
        # Container principal para Spoofing Modules
        self.spoofing_frame = ctk.CTkFrame(
            self.modules_container,
            fg_color="#1a1a2e",
            corner_radius=15,
            height=320  # Aumentei um pouco para melhor espa√ßamento
        )
        self.spoofing_frame.grid(row=0, column=0, sticky="nsew", padx=(0, 10))
        self.spoofing_frame.grid_propagate(False)

        # T√≠tulo da se√ß√£o com bot√£o refresh √† direita
        title_frame = ctk.CTkFrame(self.spoofing_frame, fg_color="transparent")
        title_frame.pack(fill="x", padx=20, pady=(20, 15))

        spoofing_title = ctk.CTkLabel(
            title_frame,
            text="SPOOFING MODULES",
            font=ctk.CTkFont(family="Segoe UI", size=16, weight="bold"),
            text_color="#6b21ff"
        )
        spoofing_title.pack(side="left")

        # Bot√£o refresh √† direita do t√≠tulo
        refresh_btn = ctk.CTkButton(
            title_frame,
            text="REFRESH",
            command=self.refresh_all_info,
            width=80,
            height=35,
            fg_color="#2d1152",
            hover_color="#4a1c6d",
            font=ctk.CTkFont(size=12, weight="bold")
        )
        refresh_btn.pack(side="right")

        # Container para as abas com borda sutil
        tabs_container = ctk.CTkFrame(
            self.spoofing_frame,
            fg_color="#151525",
            corner_radius=12,
            border_width=1,
            border_color="#2d1152"
        )
        tabs_container.pack(fill="both", expand=True, padx=15, pady=(0, 15))

        # Criar abas customizadas
        self.setup_custom_tabs(tabs_container)

    def setup_custom_tabs(self, parent):
        """Configura abas customizadas de forma simples e direta"""
        try:
            # Container principal das abas
            self.tabs_main_frame = ctk.CTkFrame(parent, fg_color="transparent")
            self.tabs_main_frame.pack(fill="both", expand=True, padx=10, pady=10)

            # Frame dos cabe√ßalhos das abas
            self.tab_headers_frame = ctk.CTkFrame(self.tabs_main_frame, fg_color="transparent", height=40)
            self.tab_headers_frame.pack(fill="x", pady=(0, 10))
            self.tab_headers_frame.pack_propagate(False)

            # Conte√∫do das abas - frame fixo
            self.tab_content_frame = ctk.CTkFrame(
                self.tabs_main_frame,
                fg_color="transparent"
            )
            self.tab_content_frame.pack(fill="both", expand=True)

            # Criar cabe√ßalhos das abas
            self.setup_tab_headers()

            # Criar frames de conte√∫do VAZIOS inicialmente
            self.create_empty_tab_content("HARDWARE")
            self.create_empty_tab_content("SOFTWARE")

            # Mostrar aba inicial
            self.show_tab_content("HARDWARE")

        except Exception as e:
            logger.log_error(f"Error setting up tabs: {str(e)}", "ERROR")

    def setup_tab_headers(self):
        """Configura os cabe√ßalhos das abas com estilo elegante"""
        self.tab_headers = {}

        tabs = [
            ("HARDWARE", "üñ•Ô∏è"),
            ("SOFTWARE", "</>")
        ]

        header_container = ctk.CTkFrame(self.tab_headers_frame, fg_color="transparent")
        header_container.pack(fill="both", expand=True)

        for i, (tab_name, icon) in enumerate(tabs):
            # Frame do cabe√ßalho da aba
            tab_header = ctk.CTkFrame(
                header_container,
                fg_color="#2d1152" if tab_name == "HARDWARE" else "#1a1a2e",
                corner_radius=8,
                border_width=1,
                border_color="#6b21ff" if tab_name == "HARDWARE" else "#2d1152"
            )
            tab_header.pack(side="left", fill="x", expand=True, padx=(5, 5) if i == 0 else 5)

            # Bot√£o da aba (aparentando ser um cabe√ßalho de aba)
            tab_button = ctk.CTkButton(
                tab_header,
                text=f"{icon} {tab_name}",
                command=lambda tn=tab_name: self.switch_tab(tn),
                fg_color="transparent",
                hover_color="#4a1c6d",
                height=35,
                font=ctk.CTkFont(size=12, weight="bold"),
                text_color="#ffffff" if tab_name == "HARDWARE" else "#b0b0ff"
            )
            tab_button.pack(fill="both", expand=True, padx=2, pady=2)

            self.tab_headers[tab_name] = tab_header

    def switch_tab(self, tab_name):
        """Alterna entre as abas"""
        if tab_name == self.current_tab:
            return

        try:
            # Atualizar apar√™ncia da aba anterior
            previous_header = self.tab_headers[self.current_tab]
            previous_header.configure(fg_color="#1a1a2e", border_color="#2d1152")

            # Atualizar apar√™ncia da nova aba
            new_header = self.tab_headers[tab_name]
            new_header.configure(fg_color="#2d1152", border_color="#6b21ff")

            # Atualizar conte√∫do
            self.current_tab = tab_name
            self.show_tab_content(tab_name)

            logger.log_info(f"Switched to {tab_name} tab", "UI")
        except Exception as e:
            logger.log_error(f"Error switching tab: {str(e)}", "ERROR")

    def show_tab_content(self, tab_name):
        """Mostra o conte√∫do da aba selecionada"""
        try:
            # Esconder todos os frames primeiro
            for frame_name, frame in self.tab_frames.items():
                if frame and frame.winfo_exists():
                    frame.pack_forget()

            # Mostrar frame da aba atual se existir
            if tab_name in self.tab_frames and self.tab_frames[tab_name] and self.tab_frames[tab_name].winfo_exists():
                self.tab_frames[tab_name].pack(fill="both", expand=True)
            else:
                # Tentar recriar se n√£o existir
                logger.log_warning(f"Tab frame {tab_name} not found, recreating...", "UI")
                self.create_tab_content(tab_name)
                if tab_name in self.tab_frames:
                    self.tab_frames[tab_name].pack(fill="both", expand=True)
                else:
                    logger.log_error(f"Failed to create tab frame for {tab_name}", "ERROR")

        except Exception as e:
            logger.log_error(f"Error showing tab content '{tab_name}': {str(e)}", "ERROR")

    def setup_hardware_tab_skeleton(self, parent):
        """Configura apenas o esqueleto da aba hardware - sem dados"""
        try:
            # Container principal
            main_container = ctk.CTkFrame(parent, fg_color="transparent")
            main_container.pack(fill="both", expand=True)

            # Container scrollable
            scroll_frame = ctk.CTkScrollableFrame(
                main_container,
                fg_color="transparent",
                scrollbar_fg_color="#2d1152"
            )
            scroll_frame.pack(fill="both", expand=True, padx=10, pady=10)

            # Frame central
            center_frame = ctk.CTkFrame(scroll_frame, fg_color="transparent")
            center_frame.pack(expand=True, fill="both")

            self.hardware_labels = {}
            hardware_data = [
                ("", "Disk C:"),
                ("", "Disk D:"),
                ("", "Motherboard:"),
                ("", "Chassis:"),
                ("", "Bios:"),
                ("", "CPU:"),
                ("", "MAC:"),
                ("", "UUID:")
            ]

            for icon, label_text in hardware_data:
                row_frame = ctk.CTkFrame(center_frame, fg_color="transparent")
                row_frame.pack(fill="x", pady=6, padx=20)

                # √çcone
                icon_label = ctk.CTkLabel(
                    row_frame,
                    text=icon,
                    text_color="#6b21ff",
                    font=ctk.CTkFont(size=14),
                    width=30
                )
                icon_label.pack(side="left", padx=(0, 10))

                # Label
                text_label = ctk.CTkLabel(
                    row_frame,
                    text=label_text,
                    text_color="#b0b0ff",
                    font=ctk.CTkFont(size=12, weight="bold"),
                    width=120,
                    anchor="w"
                )
                text_label.pack(side="left", padx=(0, 10))

                # Valor - INICIALMENTE VAZIO/LOADING
                value_label = ctk.CTkLabel(
                    row_frame,
                    text="Loading...",
                    text_color="#ffaa00",
                    font=ctk.CTkFont(size=11),
                    anchor="center",
                    wraplength=250
                )
                value_label.pack(side="left", fill="x", expand=True)

                self.hardware_labels[label_text] = value_label

        except Exception as e:
            logger.log_error(f"Error setting up hardware skeleton: {str(e)}", "ERROR")

    def setup_software_tab_skeleton(self, parent):
        """Configura apenas o esqueleto da aba software - sem dados"""
        try:
            # Container principal
            main_container = ctk.CTkFrame(parent, fg_color="transparent")
            main_container.pack(fill="both", expand=True)

            # Container scrollable
            scroll_frame = ctk.CTkScrollableFrame(
                main_container,
                fg_color="transparent",
                scrollbar_fg_color="#2d1152"
            )
            scroll_frame.pack(fill="both", expand=True, padx=10, pady=10)

            # Frame central
            center_frame = ctk.CTkFrame(scroll_frame, fg_color="transparent")
            center_frame.pack(expand=True, fill="both")

            self.software_labels = {}
            software_data = [
                ("", "Machine GUID:"),
                ("", "FiveM GUID:"),
                ("", "Rockstar GUID:"),
                ("", "Product ID:"),
                ("", "Installation ID:"),
                ("", "Windows Activation:")
            ]

            for icon, label_text in software_data:
                row_frame = ctk.CTkFrame(center_frame, fg_color="transparent")
                row_frame.pack(fill="x", pady=6, padx=20)

                # √çcone
                icon_label = ctk.CTkLabel(
                    row_frame,
                    text=icon,
                    text_color="#00ff88",
                    font=ctk.CTkFont(size=14),
                    width=30
                )
                icon_label.pack(side="left", padx=(0, 10))

                # Label
                text_label = ctk.CTkLabel(
                    row_frame,
                    text=label_text,
                    text_color="#b0b0ff",
                    font=ctk.CTkFont(size=12, weight="bold"),
                    width=120,
                    anchor="w"
                )
                text_label.pack(side="left", padx=(0, 10))

                # Valor - INICIALMENTE VAZIO/LOADING
                value_label = ctk.CTkLabel(
                    row_frame,
                    text="Loading...",
                    text_color="#ffaa00",
                    font=ctk.CTkFont(size=11),
                    anchor="center",
                    wraplength=250
                )
                value_label.pack(side="left", fill="x", expand=True)

                self.software_labels[label_text] = value_label

        except Exception as e:
            logger.log_error(f"Error setting up software skeleton: {str(e)}", "ERROR")

    def create_empty_tab_content(self, tab_name):
        """Cria conte√∫do vazio para as abas - r√°pido e sem flash"""
        try:
            content_frame = ctk.CTkFrame(self.tab_content_frame, fg_color="transparent")

            if tab_name == "HARDWARE":
                self.setup_hardware_tab_skeleton(content_frame)
            elif tab_name == "SOFTWARE":
                self.setup_software_tab_skeleton(content_frame)

            self.tab_frames[tab_name] = content_frame

        except Exception as e:
            logger.log_error(f"Error creating empty {tab_name} tab: {str(e)}", "ERROR")

    def create_tab_content(self, tab_name):
        """Cria o conte√∫do para cada aba e armazena no dicion√°rio"""
        try:
            content_frame = ctk.CTkFrame(self.tab_content_frame, fg_color="transparent")

            if tab_name == "HARDWARE":
                self.setup_hardware_tab(content_frame)
            elif tab_name == "SOFTWARE":
                self.setup_software_tab(content_frame)

            # Armazenar o frame criado no dicion√°rio
            self.tab_frames[tab_name] = content_frame

        except Exception as e:
            logger.log_error(f"Error creating {tab_name} tab content: {str(e)}", "ERROR")
            # Criar um frame de fallback
            fallback_frame = ctk.CTkFrame(self.tab_content_frame, fg_color="transparent")
            error_label = ctk.CTkLabel(
                fallback_frame,
                text=f"Error loading {tab_name} content",
                text_color="#ff4444"
            )
            error_label.pack(expand=True)
            self.tab_frames[tab_name] = fallback_frame

    def setup_controls(self):
        """Configura a se√ß√£o direita - Controls"""
        # Container principal para Controls
        self.controls_frame = ctk.CTkFrame(
            self.modules_container,
            fg_color="#1a1a2e",
            corner_radius=15,
            height=280
        )
        self.controls_frame.grid(row=0, column=1, sticky="nsew", padx=(10, 0))
        self.controls_frame.grid_propagate(False)

        # T√≠tulo da se√ß√£o
        controls_title = ctk.CTkLabel(
            self.controls_frame,
            text="CONTROLS",
            font=ctk.CTkFont(family="Segoe UI", size=16, weight="bold"),
            text_color="#6b21ff"
        )
        controls_title.pack(anchor="w", padx=20, pady=(20, 15))

        # Container para o conte√∫do
        controls_content = ctk.CTkFrame(self.controls_frame, fg_color="transparent")
        controls_content.pack(fill="both", expand=True, padx=20, pady=(0, 20))

        toggle_options = [
            "HWID SPOOFING",
            "MAC SPOOFING",
            "GUID SPOOFING"
        ]

        self.toggle_switches = {}
        for option in toggle_options:
            self.create_toggle_switch(controls_content, option)



    def _do_refresh_all(self):
        """Executa o refresh de forma simples"""
        try:
            if not self.controller.hw_reader:
                return

            # Mostra "Refreshing..." nos labels vis√≠veis
            if self.current_tab == "HARDWARE" and hasattr(self, 'hardware_labels'):
                for label_text in self.hardware_labels:
                    if self.hardware_labels[label_text].winfo_exists():
                        self.hardware_labels[label_text].configure(text="Refreshing...", text_color="#ffaa00")
            elif self.current_tab == "SOFTWARE" and hasattr(self, 'software_labels'):
                for label_text in self.software_labels:
                    if self.software_labels[label_text].winfo_exists():
                        self.software_labels[label_text].configure(text="Refreshing...", text_color="#ffaa00")

            # Carrega dados
            hw_data = self.controller.hw_reader.get_formatted_hardware_data(self.controller.mac_spoofer)
            if hw_data:
                hardware_mapping = {
                    "Disk C:": hw_data.get('disk_c', 'N/A'),
                    "Disk D:": hw_data.get('disk_d', 'N/A'),
                    "Motherboard:": hw_data.get('motherboard', 'N/A'),
                    "Chassis:": hw_data.get('chassis', 'N/A'),
                    "Bios:": hw_data.get('bios', 'N/A'),
                    "CPU:": hw_data.get('cpu', 'N/A'),
                    "MAC:": hw_data.get('mac', 'N/A'),
                    "UUID:": hw_data.get('smbios_uuid', 'N/A')
                }
                self.update_hardware_tab(hardware_mapping)

            sw_data = self.controller.hw_reader.get_software_identifiers()
            if sw_data:
                software_mapping = {
                    "Machine GUID:": sw_data.get('machine_guid', 'N/A'),
                    "FiveM GUID:": sw_data.get('fivem_guid', 'N/A'),
                    "Rockstar GUID:": sw_data.get('rockstar_guid', 'N/A'),
                    "Product ID:": sw_data.get('product_id', 'N/A'),
                    "Installation ID:": sw_data.get('installation_id', 'N/A'),
                    "Windows Activation:": sw_data.get('windows_activation', 'N/A')
                }
                self.update_software_tab(software_mapping)

            logger.log_success("System information refreshed", "SYSTEM")
            self.show_toast("Information updated", "success")

        except Exception as e:
            logger.log_error(f"Error during refresh: {str(e)}", "SYSTEM")
            self.show_toast("Refresh failed", "error")

    def refresh_all_info(self):
        """Refresh simplificado - sem complica√ß√µes"""
        try:
            logger.log_info("Refreshing system information...", "SYSTEM")

            # Apenas agenda o refresh
            self.root.after(100, self._do_refresh_all)

        except Exception as e:
            logger.log_error(f"Error scheduling refresh: {str(e)}", "SYSTEM")

    def setup_hardware_tab(self, parent):
        """Configura o conte√∫do da aba HARDWARE com layout centralizado"""
        try:
            # Container principal
            main_container = ctk.CTkFrame(parent, fg_color="transparent")
            main_container.pack(fill="both", expand=True)

            # Container scrollable para conte√∫do
            scroll_frame = ctk.CTkScrollableFrame(
                main_container,
                fg_color="transparent",
                scrollbar_fg_color="#2d1152",
                scrollbar_button_color="#6b21ff",
                scrollbar_button_hover_color="#4a1c6d"
            )
            scroll_frame.pack(fill="both", expand=True, padx=10, pady=10)

            # Frame para centralizar o conte√∫do
            center_frame = ctk.CTkFrame(scroll_frame, fg_color="transparent")
            center_frame.pack(expand=True, fill="both")

            self.hardware_labels = {}
            hardware_data = [
                ("", "Disk C:", "disk_c"),
                ("", "Disk D:", "disk_d"),
                ("", "Motherboard:", "motherboard"),
                ("", "Chassis:", "chassis"),
                ("", "Bios:", "bios"),
                ("", "CPU:", "cpu"),
                ("", "MAC:", "mac"),
                ("", "UUID:", "smbios_uuid")
            ]

            for icon, label_text, key in hardware_data:
                row_frame = ctk.CTkFrame(center_frame, fg_color="transparent")
                row_frame.pack(fill="x", pady=6, padx=20)

                # √çcone
                icon_label = ctk.CTkLabel(
                    row_frame,
                    text=icon,
                    text_color="#6b21ff",
                    font=ctk.CTkFont(size=14),
                    width=30
                )
                icon_label.pack(side="left", padx=(0, 10))

                # Label
                text_label = ctk.CTkLabel(
                    row_frame,
                    text=label_text,
                    text_color="#b0b0ff",
                    font=ctk.CTkFont(size=12, weight="bold"),
                    width=120,
                    anchor="w"
                )
                text_label.pack(side="left", padx=(0, 10))

                # Valor
                value_label = ctk.CTkLabel(
                    row_frame,
                    text="Loading...",
                    text_color="#ffaa00",
                    font=ctk.CTkFont(size=11),
                    anchor="center",
                    wraplength=250
                )
                value_label.pack(side="left", fill="x", expand=True)

                self.hardware_labels[label_text] = value_label

        except Exception as e:
            logger.log_error(f"Error setting up hardware tab: {str(e)}", "ERROR")
        
    def setup_software_tab(self, parent):
        """Configura o conte√∫do da aba SOFTWARE com layout centralizado"""
        try:
            # Container principal
            main_container = ctk.CTkFrame(parent, fg_color="transparent")
            main_container.pack(fill="both", expand=True)

            # Container scrollable para conte√∫do
            scroll_frame = ctk.CTkScrollableFrame(
                main_container,
                fg_color="transparent",
                scrollbar_fg_color="#2d1152",
                scrollbar_button_color="#6b21ff",
                scrollbar_button_hover_color="#4a1c6d"
            )
            scroll_frame.pack(fill="both", expand=True, padx=10, pady=10)

            # Frame para centralizar o conte√∫do
            center_frame = ctk.CTkFrame(scroll_frame, fg_color="transparent")
            center_frame.pack(expand=True, fill="both")

            self.software_labels = {}
            software_data = [
                ("", "Machine GUID:", "machine_guid"),
                ("", "FiveM GUID:", "fivem_guid"),
                ("", "Rockstar GUID:", "rockstar_guid"),
                ("", "Product ID:", "product_id"),
                ("", "Installation ID:", "installation_id"),
                ("", "Windows Activation:", "windows_activation")
            ]

            for icon, label_text, key in software_data:
                row_frame = ctk.CTkFrame(center_frame, fg_color="transparent")
                row_frame.pack(fill="x", pady=6, padx=20)

                # √çcone
                icon_label = ctk.CTkLabel(
                    row_frame,
                    text=icon,
                    text_color="#00ff88",
                    font=ctk.CTkFont(size=14),
                    width=30
                )
                icon_label.pack(side="left", padx=(0, 10))

                # Label
                text_label = ctk.CTkLabel(
                    row_frame,
                    text=label_text,
                    text_color="#b0b0ff",
                    font=ctk.CTkFont(size=12, weight="bold"),
                    width=120,
                    anchor="w"
                )
                text_label.pack(side="left", padx=(0, 10))

                # Valor
                value_label = ctk.CTkLabel(
                    row_frame,
                    text="Loading...",
                    text_color="#ffaa00",
                    font=ctk.CTkFont(size=11),
                    anchor="center",
                    wraplength=250
                )
                value_label.pack(side="left", fill="x", expand=True)

                self.software_labels[label_text] = value_label

        except Exception as e:
            logger.log_error(f"Error setting up software tab: {str(e)}", "ERROR")

    def _set_hardware_error_states(self):
        """Set error states for hardware labels"""
        try:
            if hasattr(self, 'hardware_labels'):
                for label_text in self.hardware_labels:
                    if label_text in self.hardware_labels and self.hardware_labels[label_text].winfo_exists():
                        self.hardware_labels[label_text].configure(text="Error loading", text_color="#ff4444")
        except Exception as e:
            logger.log_error(f"Error setting hardware error states: {str(e)}", "UI")

    def _set_software_error_states(self):
        """Set error states for software labels"""
        try:
            if hasattr(self, 'software_labels'):
                for label_text in self.software_labels:
                    if label_text in self.software_labels and self.software_labels[label_text].winfo_exists():
                        self.software_labels[label_text].configure(text="Error loading", text_color="#ff4444")
        except Exception as e:
            logger.log_error(f"Error setting software error states: {str(e)}", "UI")

    def update_hardware_tab(self, hardware_mapping):
        """Atualiza os labels na aba Hardware com tratamento de erro e color coding"""
        try:
            for key, value in hardware_mapping.items():
                if key in self.hardware_labels and self.hardware_labels[key].winfo_exists():
                    display_value = str(value)
                    if len(display_value) > 30:
                        display_value = display_value[:27] + "..."

                    # Color coding based on value
                    if display_value in ['N/A', 'Error loading', 'Loading...', 'Refreshing...']:
                        text_color = "#ff4444" if display_value == "Error loading" else "#ffaa00" if display_value in ["Loading...", "Refreshing..."] else "#888888"
                    elif "üé≠" in display_value:  # Spoofed MAC
                        text_color = "#00ff88"
                    else:  # Normal data
                        text_color = "#ffffff"

                    self.hardware_labels[key].configure(text=display_value, text_color=text_color)

        except Exception as e:
            logger.log_error(f"Error updating hardware tab: {str(e)}", "ERROR")

    def update_software_tab(self, software_mapping):
        """Atualiza os labels na aba Software com tratamento de erro e color coding"""
        try:
            for key, value in software_mapping.items():
                if key in self.software_labels and self.software_labels[key].winfo_exists():
                    display_value = str(value)
                    if len(display_value) > 30:
                        display_value = display_value[:27] + "..."

                    # Color coding based on value
                    if display_value in ['N/A', 'Error loading', 'Loading...', 'Refreshing...']:
                        if display_value == "Error loading":
                            text_color = "#ff4444"
                        elif display_value in ["Loading...", "Refreshing..."]:
                            text_color = "#ffaa00"
                        elif display_value == "N/A":
                            text_color = "#888888"
                        else:
                            text_color = "#ffffff"
                    elif "Ativado" in display_value or "Activated" in display_value:
                        text_color = "#00ff88"  # Green for activated Windows
                    elif "N√£o Instalado" in display_value or "Not Installed" in display_value:
                        text_color = "#ffaa00"  # Orange for not installed
                    elif "Erro" in display_value or "Error" in display_value:
                        text_color = "#ff4444"  # Red for errors
                    else:
                        text_color = "#ffffff"  # White for normal data

                    self.software_labels[key].configure(text=display_value, text_color=text_color)

        except Exception as e:
            logger.log_error(f"Error updating software tab: {str(e)}", "ERROR")



    def create_toggle_switch(self, parent, option):
        switch_frame = ctk.CTkFrame(parent, fg_color="transparent")
        switch_frame.pack(fill="x", pady=6)
        
        switch_frame.grid_columnconfigure(0, weight=1)
        switch_frame.grid_columnconfigure(1, weight=0)
        
        label = ctk.CTkLabel(switch_frame, text=option, text_color="#b0b0ff",
                           font=ctk.CTkFont(size=12))
        label.grid(row=0, column=0, sticky="w", padx=(0, 10))
        
        switch = ctk.CTkSwitch(
            switch_frame,
            text="",
            width=45,
            height=20,
            switch_width=35,
            switch_height=16,
            corner_radius=8,
            border_width=1,
            button_color="#ffffff",
            button_hover_color="#f0f0f0",
            fg_color="#3a3a3a",
            progress_color="#6b21ff",
            border_color="#555555",
            command=lambda s=option: self.on_toggle_changed(s)
        )
        switch.grid(row=0, column=1, sticky="e", padx=(0, 5))
        
        self.toggle_switches[option] = switch

    def on_toggle_changed(self, option):
        new_state = self.toggle_switches[option].get()
        self.toggle_states[option] = new_state
        
        state_text = "ENABLED" if new_state else "DISABLED"
        logger.log_info(f"{option}: {state_text}", "CONTROL")
        
        if new_state:
            self.show_toast(f"{option} activated", "success")
            
            # Handle specific toggles
            if option == "MAC SPOOFING":
                self.on_mac_toggle_changed()
            # Adicione outros handlers aqui para HWID, EFI, etc.
                
        else:
            self.show_toast(f"{option} deactivated", "info")
            
            # Handle toggle deactivation
            if option == "MAC SPOOFING":
                self.on_mac_reset()

    def on_mac_toggle_changed(self):
        """Handle MAC spoofing activation"""
        logger.log_info("MAC spoofing requested", "MAC")
        
        # Show interface selection dialog
        dialog = InterfaceSelectionDialog(self.root, self.controller.mac_spoofer)
        selected_interface, vendor_oui, selected_mac = dialog.show()
        # If user selected an interface, store it and notify user. Do NOT perform spoof now.
        if selected_interface:
            self.selected_interface = selected_interface
            self.selected_vendor = vendor_oui
            self.selected_mac = selected_mac
            logger.log_info(f"MAC selection stored for {selected_interface} (vendor={vendor_oui})", "MAC")
            self.show_toast("MAC interface selected. Spoof will run when you Start Spoofing.", "info")
        else:
            # User cancelled, reset the toggle and clear selection
            self.toggle_switches["MAC SPOOFING"].deselect()
            self.toggle_states["MAC SPOOFING"] = False
            self.selected_interface = None
            self.selected_vendor = None
            self.selected_mac = None
            logger.log_info("MAC spoofing cancelled by user", "MAC")

    def execute_mac_spoofing(self, interface_name, vendor_oui):
        """Execute MAC spoofing in background thread"""
        try:
            logger.log_info(f"Starting MAC spoofing on {interface_name}", "MAC")
            self.update_status(f"Spoofing MAC on {interface_name}...")
            
            success = self.controller.mac_spoofer.spoof_mac_address(interface_name, vendor_oui)
            
            if success:
                logger.log_success(f"MAC spoofing completed on {interface_name}", "MAC")
                self.show_toast("MAC address spoofed successfully!", "success")
                
                # Refresh hardware info to show new MAC
                self.root.after(1000, self.refresh_all_info)
            else:
                logger.log_error(f"MAC spoofing failed on {interface_name}", "MAC")
                self.show_toast("MAC spoofing failed!", "error")
                
                # Reset the toggle on failure
                self.root.after(0, self.reset_mac_toggle)
                
        except Exception as e:
            logger.log_error(f"MAC spoofing error: {str(e)}", "MAC")
            self.show_toast("MAC spoofing error occurred!", "error")
            self.root.after(0, self.reset_mac_toggle)

    def on_mac_reset(self):
        """Handle MAC reset (when toggle is turned off)"""
        logger.log_info("MAC reset requested", "MAC")
        
        if self.controller.mac_spoofer.current_interface:
            thread = threading.Thread(
                target=self.execute_mac_reset,
                args=(self.controller.mac_spoofer.current_interface,),
                daemon=True
            )
            thread.start()
        else:
            logger.log_warning("No active MAC spoofing session to reset", "MAC")
            self.show_toast("No active MAC spoofing to reset", "info")

    def execute_mac_reset(self, interface_name):
        """Execute MAC reset in background thread"""
        try:
            logger.log_info(f"Resetting MAC on {interface_name}", "MAC")
            self.update_status(f"Resetting MAC on {interface_name}...")
            
            success = self.controller.mac_spoofer.reset_mac_address(interface_name)
            
            if success:
                logger.log_success(f"MAC reset completed on {interface_name}", "MAC")
                self.show_toast("MAC address reset to original!", "success")
                
                # Refresh hardware info to show original MAC
                self.root.after(1000, self.refresh_all_info)
            else:
                logger.log_error(f"MAC reset failed on {interface_name}", "MAC")
                self.show_toast("MAC reset failed!", "error")
                
        except Exception as e:
            logger.log_error(f"MAC reset error: {str(e)}", "MAC")
            self.show_toast("MAC reset error occurred!", "error")

    def reset_mac_toggle(self):
        """Reset MAC toggle to off state"""
        self.toggle_switches["MAC SPOOFING"].deselect()
        self.toggle_states["MAC SPOOFING"] = False

    def setup_logs_area(self, parent):
        logs_container = ctk.CTkFrame(parent, fg_color="#1a1a2e", corner_radius=15)
        logs_container.grid(row=1, column=0, sticky="nsew")
        logs_container.grid_columnconfigure(0, weight=1)
        logs_container.grid_rowconfigure(1, weight=1)
        
        logs_header = ctk.CTkFrame(logs_container, fg_color="transparent")
        logs_header.grid(row=0, column=0, sticky="ew", padx=20, pady=(15, 10))
        logs_header.grid_columnconfigure(0, weight=1)
        
        logs_title = ctk.CTkLabel(
            logs_header,
            text="EXECUTION LOG - REAL TIME MONITORING",
            font=ctk.CTkFont(family="Segoe UI", size=16, weight="bold"),
            text_color="#ffffff"
        )
        logs_title.grid(row=0, column=0, sticky="w")
        
        controls_frame = ctk.CTkFrame(logs_header, fg_color="transparent")
        controls_frame.grid(row=0, column=1, sticky="e")
        
        clear_btn = ctk.CTkButton(
            controls_frame,
            text="Clear",
            command=self.clear_logs,
            width=80,
            height=30,
            fg_color="#2d1152",
            hover_color="#4a1c6d"
        )
        clear_btn.pack(side="left", padx=5)

        export_btn = ctk.CTkButton(
            controls_frame,
            text="Export",
            command=self.export_logs,
            width=80,
            height=30,
            fg_color="#2d1152",
            hover_color="#4a1c6d"
        )
        export_btn.pack(side="left", padx=5)
        
        text_frame = ctk.CTkFrame(logs_container, fg_color="transparent")
        text_frame.grid(row=1, column=0, sticky="nsew", padx=20, pady=(0, 20))
        text_frame.grid_columnconfigure(0, weight=1)
        text_frame.grid_rowconfigure(0, weight=1)
        
        self.logs_text = ctk.CTkTextbox(
            text_frame,
            font=ctk.CTkFont(family="Consolas", size=12),
            wrap="word",
            fg_color="#0f0f23",
            text_color="#e0e0ff",
            border_width=2,
            border_color="#2d1152",
            corner_radius=10
        )
        self.logs_text.grid(row=0, column=0, sticky="nsew")

    def setup_log_highlighting(self):
        self.logs_text.tag_config("error", foreground="#ff4444")
        self.logs_text.tag_config("success", foreground="#00ff88")
        self.logs_text.tag_config("warning", foreground="#ffaa00")
        self.logs_text.tag_config("system", foreground="#6b21ff")
        self.logs_text.tag_config("hardware", foreground="#b0b0ff")
        self.logs_text.tag_config("mac", foreground="#b0b0ff")  # ‚Üê ADICIONADO: Cor para logs MAC
        self.logs_text.tag_config("info", foreground="#e0e0ff")

    def update_system_stats(self):
        try:
            cpu_usage = SystemStats.get_cpu_usage()
            memory_usage = SystemStats.get_memory_usage()
            disk_usage = SystemStats.get_disk_usage()
            
            self.update_stat_card(self.cpu_card, f"{cpu_usage:.1f}%", cpu_usage/100)
            self.update_stat_card(self.memory_card, f"{memory_usage:.1f}%", memory_usage/100)
            self.update_stat_card(self.disk_card, f"{disk_usage:.1f}%", disk_usage/100)
            
        except Exception as e:
            logger.log_error(f"Error updating stats: {e}", "SYSTEM")
        
        self.root.after(2000, self.update_system_stats)

    def update_stat_card(self, card, value, progress):
        for widget in card.winfo_children():
            if isinstance(widget, ctk.CTkLabel):
                if widget.cget("text").isdigit() or "%" in widget.cget("text"):
                    widget.configure(text=value)
            elif isinstance(widget, ctk.CTkProgressBar):
                widget.set(progress)

    def update_status(self, message, is_error=False, is_success=False):
        if is_error:
            dot_color = "#ff4444"
        elif is_success:
            dot_color = "#00ff88"
        else:
            dot_color = "#ffaa00"
            
        self.status_dot.configure(text_color=dot_color)
        self.status_text.configure(text=message)

    def show_toast(self, message, toast_type="info"):
        ToastNotification(self.root, message, toast_type)

    def switch_theme(self, theme):
        self.current_theme = theme.lower()
        self.show_toast(f"Theme switched to {theme}", "info")

    def start_spoofing_sequence(self):
        if self.cleaning_in_progress:
            return
        
        from tkinter import messagebox
            
        confirm = messagebox.askyesno(
            "CONFIRM SPOOFING",
            "WARNING: This will PERFORM SYSTEM MODIFICATIONS:\n\n"
            "‚Ä¢ TERMINATE Discord, FiveM, Steam processes\n"
            "‚Ä¢ RENAME Discord RPC folders to break tracking\n"
            "‚Ä¢ CLEAN FiveM cache and registry traces\n"
            "‚Ä¢ RESET network configurations\n"
            "‚Ä¢ DELETE temporary system files\n\n"
            "This is NOT a simulation - changes will be made!\n\n"
            "Continue with spoofing protocol?",
            icon='warning'
        )
        
        if not confirm:
            logger.log_warning("Spoofing cancelled by user", "USER")
            return

        self.start_spoofing()

    def start_spoofing(self):
        self.cleaning_in_progress = True
        self.spoof_button.configure(state="disabled", text="SPOOFING...")
        self.spoof_button.start_pulse()
        self.clear_logs()
        self.update_status("Executing spoofing protocol")
        self.circular_progress.set_progress(0)
        
        enabled_modules = [module for module, state in self.toggle_states.items() if state]
        if enabled_modules:
            logger.log_info(f"Active: {', '.join(enabled_modules)}", "MODULES")
        
        self.show_toast("Starting spoofing...", "info")
        
        self.controller.start_spoofing_thread(
            self.toggle_states,
            self.selected_interface,
            self.selected_vendor,
            self.selected_mac
        )

    def handle_spoofing_start(self):
        """Callback: A√ß√µes de UI quando o spoofing come√ßa."""
        # Este m√©todo j√° √© chamado em start_spoofing, ent√£o podemos manter simples
        pass

    def handle_spoofing_success(self):
        """Callback: A√ß√µes de UI em caso de sucesso."""
        self.last_spoof_time = self.controller.last_spoof_time
        if self.controller.hw_reader:
            logger.log_info("Refreshing hardware and software display after spoof...", "SYSTEM")
            self.refresh_all_info()
        
        self.circular_progress.set_progress(100)
        self.update_status("Spoofing completed!", is_success=True)
        self.show_toast("System successfully spoofed!", "success")

    def handle_spoofing_failure(self, reason=""):
        """Callback: A√ß√µes de UI em caso de falha."""
        self.circular_progress.set_progress(75) # Progresso parcial
        self.update_status(reason, is_error=True)
        self.show_toast(f"Spoofing failed: {reason}", "error")

    def handle_spoofing_finish(self):
        """Callback: A√ß√µes de UI ao finalizar (sucesso ou falha)."""
        self.cleaning_in_progress = False
        self.spoof_button.configure(state="normal", text="START SPOOFING")
        self.spoof_button.stop_pulse()

    def clear_logs(self):
        self.logs_text.configure(state="normal")
        self.logs_text.delete("1.0", "end")
        self.logs_text.configure(state="disabled")
        logger.log_info("Log cleared", "SYSTEM")
        self.show_toast("Logs cleared", "info")

    def export_logs(self):
        try:
            filename = f"midnight_logs_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt"
            with open(filename, 'w', encoding='utf-8') as f:
                f.write(self.logs_text.get("1.0", "end"))
            self.show_toast(f"Logs exported to {filename}", "success")
            logger.log_info(f"Logs exported to {filename}", "SYSTEM")
        except Exception as e:
            self.show_toast(f"Export failed: {str(e)}", "error")
            logger.log_error(f"Export failed: {str(e)}", "ERROR")

    def show_dashboard(self):
        """TODO: Integrar painel de dashboard com estat√≠sticas detalhadas"""
        self.show_toast("Dashboard loaded", "info")
        logger.log_info("Dashboard panel opened - TODO: Implement detailed statistics", "NAVIGATION")

    def show_spoof_tools(self):
        """TODO: Integrar ferramentas avan√ßadas de spoofing"""
        self.show_toast("Spoof tools panel", "info")
        logger.log_info("Spoof tools panel opened - TODO: Implement advanced spoofing tools", "NAVIGATION")

    def show_history(self):
        """TODO: Integrar hist√≥rico de opera√ß√µes"""
        self.show_toast("History panel", "info")
        logger.log_info("History panel opened - TODO: Implement operation history", "NAVIGATION")

    def show_settings(self):
        """TODO: Integrar configura√ß√µes avan√ßadas"""
        self.show_toast("Settings panel", "info")
        logger.log_info("Settings panel opened - TODO: Implement advanced settings", "NAVIGATION")

    def show_about(self):
        from tkinter import messagebox
        about_text = """
        Midnight Spoofer Beta
        Advanced system identity protection

        ‚Ä¢ Discord RPC spoofing
        ‚Ä¢ FiveM cache cleaning
        ‚Ä¢ Network configuration reset
        ‚Ä¢ Registry sanitization
        ‚Ä¢ Hardware ID detection
        ‚Ä¢ MAC Address spoofing

        Always run as Administrator
        for full functionality.

        Under active development
        """
        messagebox.showinfo("About Midnight Spoofer", about_text)

    def run(self):
        self.root.mainloop()


# legacy\src\dashboard\components\buttons.py

# src/gui/components/buttons.py

import customtkinter as ctk

class AnimatedButton(ctk.CTkButton):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.default_fg_color = self.cget("fg_color")
        self.hover_fg_color = "#4a1c6d"
        self.animation_running = False
        self.bind('<Enter>', self.on_enter)
        self.bind('<Leave>', self.on_leave)
        
    def on_enter(self, event):
        self.configure(fg_color=self.hover_fg_color)
        
    def on_leave(self, event):
        if not self.animation_running:
            self.configure(fg_color=self.default_fg_color)
    
    def start_pulse(self):
        self.animation_running = True
        self._pulse_animation()
    
    def stop_pulse(self):
        self.animation_running = False
        self.configure(fg_color=self.default_fg_color)
    
    def _pulse_animation(self):
        if not self.animation_running:
            return
            
        colors = ["#2d1152", "#3a1668", "#471c7e", "#542194", "#6127aa"]
        current = 0
        
        def update_color():
            nonlocal current
            if self.animation_running:
                self.configure(fg_color=colors[current])
                current = (current + 1) % len(colors)
                self.after(200, update_color)
        
        update_color()

# legacy\src\dashboard\components\particles.py

# src/gui/components/particles.py

import random
import math

class ParticleSystem:
    def __init__(self, canvas, width, height):
        self.canvas = canvas
        self.width = width
        self.height = height
        self.particles = []
        self.connections = []
        
    def create_particles(self, count=50):
        for _ in range(count):
            particle = {
                'x': random.uniform(0, self.width),
                'y': random.uniform(0, self.height),
                'vx': random.uniform(-0.5, 0.5),
                'vy': random.uniform(-0.5, 0.5),
                'radius': random.uniform(1, 3),
                'color': random.choice(['#6b21ff', '#4a1c6d', '#2d1152', "#141425"]),
                'id': None
            }
            self.particles.append(particle)
    
    def draw_particles(self):
        for particle in self.particles:
            x1 = particle['x'] - particle['radius']
            y1 = particle['y'] - particle['radius']
            x2 = particle['x'] + particle['radius']
            y2 = particle['y'] + particle['radius']
            particle['id'] = self.canvas.create_oval(x1, y1, x2, y2, 
                                                   fill=particle['color'], 
                                                   outline="", tags="particle")
    
    def draw_connections(self):
        self.connections.clear()
        for i, p1 in enumerate(self.particles):
            for j, p2 in enumerate(self.particles[i+1:], i+1):
                distance = math.sqrt((p1['x']-p2['x'])**2 + (p1['y']-p2['y'])**2)
                if distance < 100:
                    # Use solid color instead of alpha
                    color = '#36365a'  # Solid light purple
                    line_id = self.canvas.create_line(p1['x'], p1['y'], p2['x'], p2['y'],
                                                     fill=color, width=1, tags="connection")
                    self.connections.append(line_id)
    
    def update(self):
        for particle in self.particles:
            particle['x'] += particle['vx']
            particle['y'] += particle['vy']
            
            # Bounce off edges
            if particle['x'] <= 0 or particle['x'] >= self.width:
                particle['vx'] *= -1
            if particle['y'] <= 0 or particle['y'] >= self.height:
                particle['vy'] *= -1
            
            # Update canvas position
            if particle['id']:
                x1 = particle['x'] - particle['radius']
                y1 = particle['y'] - particle['radius']
                x2 = particle['x'] + particle['radius']
                y2 = particle['y'] + particle['radius']
                self.canvas.coords(particle['id'], x1, y1, x2, y2)

# legacy\src\dashboard\components\progress.py

# src/gui/components/progress.py

import customtkinter as ctk

class CircularProgress(ctk.CTkCanvas):
    def __init__(self, parent, size=200, **kwargs):
        super().__init__(parent, width=size, height=size, **kwargs)
        self.size = size
        self.center = size // 2
        self.radius = size // 2 - 10
        self.progress = 0
        
        self.configure(bg="#0a0a1a", highlightthickness=0)
        self.draw_background()
        self.draw_progress()
    
    def draw_background(self):
        self.create_oval(10, 10, self.size-10, self.size-10, 
                        outline="#1a1a2e", width=8, fill="#0a0a1a")
    
    def draw_progress(self):
        self.delete("progress")
        angle = 360 * self.progress / 100
        
        self.create_arc(10, 10, self.size-10, self.size-10,
                       start=90, extent=-angle,
                       outline="#6b21ff", width=8, style="arc", tags="progress")
        
        # Progress text
        self.create_text(self.center, self.center, text=f"{int(self.progress)}%",
                        fill="white", font=("Segoe UI", 20, "bold"), tags="progress")
    
    def set_progress(self, value):
        self.progress = max(0, min(100, value))
        self.draw_progress()

# legacy\src\dashboard\components\stats.py

# src/gui/components/stats.py

import psutil

class SystemStats:
    @staticmethod
    def get_cpu_usage():
        return psutil.cpu_percent(interval=0.1)
    
    @staticmethod
    def get_memory_usage():
        memory = psutil.virtual_memory()
        return memory.percent
    
    @staticmethod
    def get_disk_usage():
        disk = psutil.disk_usage('/')
        return disk.percent

# legacy\src\dashboard\components\toast.py

# src/gui/components/toast.py
import customtkinter as ctk
import time

class ToastNotification:
    def __init__(self, parent, message, toast_type="info"):
        self.parent = parent
        self.message = message
        self.toast_type = toast_type
        
        self.toast = ctk.CTkToplevel(parent)
        self.toast.overrideredirect(True)
        self.toast.attributes("-topmost", True)
        self.toast.attributes("-alpha", 0.0)
        
        self.setup_toast()
        self.animate_in()
    
    def setup_toast(self):
        colors = {
            "info": ("#6b21ff", "#1a1a2e"),
            "success": ("#00ff88", "#1a2e1a"),
            "warning": ("#ffaa00", "#2e2a1a"),
            "error": ("#ff4444", "#2e1a1a")
        }
        
        bg_color, frame_color = colors.get(self.toast_type, colors["info"])
        
        self.toast.configure(fg_color=frame_color)
        self.toast.geometry("300x60")
        
        # Position in top right
        x = self.parent.winfo_rootx() + self.parent.winfo_width() - 320
        y = self.parent.winfo_rooty() + 50
        self.toast.geometry(f"+{x}+{y}")
        
        frame = ctk.CTkFrame(self.toast, fg_color=bg_color, corner_radius=10)
        frame.pack(fill="both", padx=10, pady=10)
        
        label = ctk.CTkLabel(frame, text=self.message, text_color="white")
        label.pack(expand=True, fill="both", padx=20, pady=15)
    
    def animate_in(self):
        for i in range(10):
            alpha = i * 0.1
            self.toast.attributes("-alpha", alpha)
            self.toast.update()
            time.sleep(0.02)
        
        self.toast.after(3000, self.animate_out)
    
    def animate_out(self):
        for i in range(10, -1, -1):
            alpha = i * 0.1
            self.toast.attributes("-alpha", alpha)
            self.toast.update()
            time.sleep(0.02)
        
        self.toast.destroy()

# legacy\src\spoofers\guid_spoofer\guid_paths.py

"""
GUID-specific registry paths and system locations
"""
import os

GUID_REGISTRY_PATHS = {
    'windows_system': [
        {
            'hive': 'HKLM',
            'path': r"SOFTWARE\Microsoft\Cryptography",
            'name': 'MachineGuid',
            'description': 'Windows Machine GUID',
            'backup': True,
            'critical': True
        },
        {
            'hive': 'HKLM',
            'path': r"SOFTWARE\Microsoft\SQMClient",
            'name': 'MachineId',
            'description': 'Windows SQM Client Machine ID',
            'backup': True,
            'critical': False
        },
        {
            'hive': 'HKLM',
            'path': r"SOFTWARE\Microsoft\Windows NT\CurrentVersion",
            'name': 'ProductId',
            'description': 'Windows Product ID',
            'backup': True,
            'critical': False
        },
        {
            'hive': 'HKLM',
            'path': r"SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProfileGuid",
            'name': 'ProfileGuid',
            'description': 'Windows Profile GUID',
            'backup': True,
            'critical': False
        }
    ],
    'rockstar_games': [
        {
            'hive': 'HKLM',
            'path': r"SOFTWARE\WOW6432Node\Rockstar Games\Grand Theft Auto V",
            'name': 'MachineGUID',
            'description': 'Rockstar GTA V Machine GUID',
            'backup': True,
            'critical': False
        },
        {
            'hive': 'HKLM',
            'path': r"SOFTWARE\Rockstar Games",
            'name': 'MachineGUID',
            'description': 'Rockstar Games Machine GUID',
            'backup': True,
            'critical': False
        },
        {
            'hive': 'HKLM',
            'path': r"SOFTWARE\Rockstar Games\Launcher",
            'name': 'GUID',
            'description': 'Rockstar Launcher GUID',
            'backup': True,
            'critical': False
        },
        {
            'hive': 'HKLM',
            'path': r"SOFTWARE\Rockstar Games\Social Club",
            'name': 'MachineGUID',
            'description': 'Rockstar Social Club Machine GUID',
            'backup': True,
            'critical': False
        },
        {
            'hive': 'HKCU',
            'path': r"SOFTWARE\Rockstar Games\Social Club",
            'name': 'GUID',
            'description': 'Rockstar Social Club User GUID',
            'backup': True,
            'critical': False
        }
    ],
    'fivem': [
        {
            'hive': 'HKCU',
            'path': r"Software\Cfx.re",
            'name': 'guid',
            'description': 'FiveM Cfx.re GUID',
            'backup': True,
            'critical': True
        },
        {
            'hive': 'HKCU',
            'path': r"Software\CitizenFX",
            'name': 'guid',
            'description': 'FiveM CitizenFX GUID',
            'backup': True,
            'critical': True
        }
    ],
    'steam_tweaks': [
        {
            'hive': 'HKCU',
            'path': r"Software\Valve\Steam",
            'name': 'ActiveProcess',
            'description': 'Steam Active Process Flag',
            'backup': True,
            'critical': False
        }
    ]
}

GUID_SYSTEM_PATHS = {
    'cache_locations': [
        os.path.join(os.getenv('LOCALAPPDATA', ''), 'FiveM'),
        os.path.join(os.getenv('APPDATA', ''), 'CitizenFX'),
        os.path.join(os.getenv('LOCALAPPDATA', ''), 'Rockstar Games'),
        os.path.join(os.getenv('DOCUMENTS', ''), 'Rockstar Games'),
        os.path.join(os.getenv('PROGRAMDATA', ''), 'Rockstar Games'),
        os.path.join(os.getenv('APPDATA', ''), 'Social Club'),
        os.path.join(os.getenv('LOCALAPPDATA', ''), 'Steam'),
    ],
    'registry_backups': [
        "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Cryptography",
        "HKEY_LOCAL_MACHINE\\SOFTWARE\\Rockstar Games",
        "HKEY_LOCAL_MACHINE\\SOFTWARE\\WOW6432Node\\Rockstar Games",
        "HKEY_CURRENT_USER\\Software\\Cfx.re",
        "HKEY_CURRENT_USER\\Software\\CitizenFX",
        "HKEY_LOCAL_MACHINE\\SOFTWARE\\CitizenFX"
    ]
}


# legacy\src\spoofers\guid_spoofer\guid_spoofer.py

# src/spoofers/guid_spoofer/guid_spoofer.py

import uuid
import os
import winreg
import shutil
import hashlib
import random
import subprocess
import time
from typing import Dict, List
from utils.logger import logger
from utils.registry_checker import RegistryChecker, RegistryError
from .guid_paths import GUID_REGISTRY_PATHS, GUID_SYSTEM_PATHS

class GUIDSpoofer:
    def __init__(self):
        """Initializes the GUIDSpoofer with comprehensive registry coverage."""
        self.registry = RegistryChecker()
        self.backup_dir = "registry_backups"
        os.makedirs(self.backup_dir, exist_ok=True)
        
        self.registry_paths = GUID_REGISTRY_PATHS
        self.system_paths = GUID_SYSTEM_PATHS

        # GUID patterns used by different systems
        self.guid_patterns = {
            'standard': lambda: str(uuid.uuid4()),
            'windows_machine': self._generate_windows_machine_guid,
            'rockstar': self._generate_rockstar_guid,
            'fivem': self._generate_fivem_guid
        }

    def spoof_guid(self) -> bool:
        """
        Executes comprehensive GUID spoofing covering:
        - Windows Machine GUID
        - Rockstar Games GUIDs (multiple locations)
        - FiveM/CitizenFX GUIDs
        - Social Club GUIDs
        - Windows Profile GUIDs
        - Steam related GUIDs
        """
        logger.log_info("üöÄ INITIATING COMPREHENSIVE GUID SPOOFING PROTOCOL", "GUID")
        
        try:
            # Create comprehensive backup before any changes
            self._create_comprehensive_backup()
            
            # Generate unique GUIDs for different systems
            guid_map = self._generate_guid_map()
            
            # Execute registry modifications in transaction
            operations = self._build_comprehensive_operations(guid_map)
            
            logger.log_info("Applying GUID modifications transactionally...", "GUID")
            self.registry.transactional_write(operations)
            logger.log_success("Registry GUIDs successfully spoofed", "GUID")
            
            # Clean all related artifacts and caches
            self._clean_all_artifacts()
            
            # Additional system-level spoofing
            self._apply_system_level_spoofing(guid_map)
            
            logger.log_success("üéØ COMPREHENSIVE GUID SPOOFING COMPLETED SUCCESSFULLY", "GUID")
            return True
            
        except RegistryError as e:
            logger.log_error(f"Registry transaction failed: {e}", "GUID")
            logger.log_error("All changes have been rolled back", "GUID")
            return False
        except Exception as e:
            logger.log_error(f"Unexpected error during GUID spoofing: {e}", "GUID")
            return False

    def _generate_guid_map(self) -> Dict[str, str]:
        """Generate unique GUIDs for different systems to avoid correlation."""
        return {
            'windows_machine': self.guid_patterns['windows_machine'](),
            'rockstar_primary': self.guid_patterns['rockstar'](),
            'rockstar_secondary': self.guid_patterns['rockstar'](),
            'fivem_primary': self.guid_patterns['fivem'](),
            'fivem_secondary': self.guid_patterns['standard'](),
            'social_club': self.guid_patterns['standard'](),
            'windows_profile': self.guid_patterns['standard'](),
            'steam': self.guid_patterns['standard']()
        }

    def _generate_windows_machine_guid(self) -> str:
        """Generate Windows Machine GUID in proper format."""
        return hashlib.md5(str(random.getrandbits(256)).encode()).hexdigest().upper()

    def _generate_rockstar_guid(self) -> str:
        """Generate Rockstar-style GUID."""
        base = hashlib.sha256(str(random.getrandbits(256)).encode()).hexdigest()[:32].upper()
        return f"{base[:8]}-{base[8:12]}-{base[12:16]}-{base[16:20]}-{base[20:32]}"

    def _generate_fivem_guid(self) -> str:
        """Generate FiveM-style identifier."""
        return hashlib.sha1(str(random.getrandbits(256)).encode()).hexdigest()[:40].upper()

    def _get_guid_for_category(self, guid_map: Dict[str, str], category: str) -> str:
        """Helper to get the correct GUID from the map based on category."""
        if 'windows' in category:
            return guid_map['windows_machine']
        if 'rockstar' in category:
            return guid_map['rockstar_primary']
        if 'fivem' in category:
            return guid_map['fivem_primary']
        return guid_map['social_club'] # Fallback to social_club which is a standard GUID

    def _build_comprehensive_operations(self, guid_map: Dict[str, str]) -> List[Dict]:
        """Build comprehensive registry operations from the centralized paths file."""
        operations = []
        
        for category, paths in self.registry_paths.items():
            for path_info in paths:
                # Special handling for ProductId which needs generation
                value = self._generate_product_id() if path_info['name'] == 'ProductId' else self._get_guid_for_category(guid_map, category)
                
                operations.append({
                    "action": "write",
                    "hive": path_info['hive'],
                    "path": path_info['path'],
                    "name": path_info['name'],
                    "value": value,
                    "value_type": winreg.REG_SZ
                })

        logger.log_info(f"Built {len(operations)} registry operations", "GUID")
        return operations

    def _generate_product_id(self) -> str:
        """Generate realistic Windows Product ID."""
        return f"{random.randint(10000, 99999)}-{random.randint(10000, 99999)}-{random.randint(10000, 99999)}-{random.randint(10000, 99999)}"

    def _create_comprehensive_backup(self):
        """Create comprehensive backup of all registry locations."""
        try:
            backup_file = os.path.join(self.backup_dir, f"guid_comprehensive_backup_{int(time.time())}.reg")
            logger.log_info(f"Creating comprehensive registry backup: {backup_file}", "GUID")
            
            # Backup critical registry paths from the centralized list
            backup_paths = self.system_paths['registry_backups']
            
            for path in backup_paths:
                try:
                    subprocess.run(f'reg export "{path}" "{backup_file}_temp" /y', 
                                 shell=True, capture_output=True, timeout=10)
                except:
                    continue
                    
        except Exception as e:
            logger.log_warning(f"Backup creation partially failed: {e}", "GUID")

    def _clean_all_artifacts(self):
        """Clean all GUID-related artifacts and caches."""
        logger.log_info("Cleaning all GUID-related artifacts...", "GUID")
        
        all_paths = self.system_paths['cache_locations']
        
        success_count = 0
        for path in all_paths:
            if os.path.exists(path):
                try:
                    shutil.rmtree(path, ignore_errors=True)
                    success_count += 1
                    logger.log_success(f"Cleaned: {os.path.basename(path)}", "GUID")
                except Exception as e:
                    logger.log_warning(f"Failed to clean {path}: {e}", "GUID")
            else:
                logger.log_info(f"Path not found: {path}", "GUID")
        
        # Clear Windows recent documents
        self._clear_recent_documents()
        
        logger.log_success(f"Artifact cleaning: {success_count}/{len(all_paths)} locations cleaned", "GUID")

    def _clear_recent_documents(self):
        """Clear Windows recent documents that might contain game references."""
        try:
            recent_path = os.path.join(os.getenv('APPDATA', ''), 'Microsoft', 'Windows', 'Recent')
            if os.path.exists(recent_path):
                for item in os.listdir(recent_path):
                    item_path = os.path.join(recent_path, item)
                    try:
                        if os.path.isfile(item_path):
                            os.remove(item_path)
                        elif os.path.isdir(item_path):
                            shutil.rmtree(item_path, ignore_errors=True)
                    except:
                        continue
                logger.log_info("Cleared recent documents", "GUID")
        except Exception as e:
            logger.log_warning(f"Failed to clear recent documents: {e}", "GUID")

    def _apply_system_level_spoofing(self, guid_map: Dict[str, str]):
        """Apply additional system-level spoofing measures."""
        try:
            # Clear DNS cache
            subprocess.run('ipconfig /flushdns', shell=True, capture_output=True)
            
            # Clear Windows event logs related to games
            self._clear_game_event_logs()
            
            # Modify Windows telemetry (optional)
            self._modify_telemetry_settings()
            
            logger.log_info("Applied system-level spoofing measures", "GUID")
            
        except Exception as e:
            logger.log_warning(f"System-level spoofing partially failed: {e}", "GUID")

    def _clear_game_event_logs(self):
        """Clear Windows event logs that might contain game activity."""
        try:
            # Clear application logs that might contain game entries
            logs_to_clear = ['Application', 'System', 'Security']
            for log_name in logs_to_clear:
                try:
                    subprocess.run(f'wevtutil cl "{log_name}"', shell=True, capture_output=True)
                except:
                    continue
            logger.log_info("Cleared Windows event logs", "GUID")
        except Exception as e:
            logger.log_warning(f"Failed to clear event logs: {e}", "GUID")

    def _modify_telemetry_settings(self):
        """Modify Windows telemetry settings to reduce tracking."""
        try:
            # Disable telemetry (optional - can be controversial)
            telemetry_commands = [
                'reg add "HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\DataCollection" /v AllowTelemetry /t REG_DWORD /d 0 /f',
                'reg add "HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\DataCollection" /v AllowTelemetry /t REG_DWORD /d 0 /f'
            ]
            
            for cmd in telemetry_commands:
                try:
                    subprocess.run(cmd, shell=True, capture_output=True, timeout=5)
                except:
                    continue
                    
            logger.log_info("Modified telemetry settings", "GUID")
        except Exception as e:
            logger.log_warning(f"Failed to modify telemetry: {e}", "GUID")

    def get_spoofing_report(self) -> Dict[str, any]:
        """Generate a report of what was spoofed."""
        return {
            "status": "completed",
            "backup_created": True,
            "registry_modified": True,
            "artifacts_cleaned": True,
            "system_modified": True,
            "timestamp": int(time.time())
        }


# legacy\src\spoofers\hwid_spoofer\hwid_paths.py

"""
HWID-specific registry paths (placeholder for future implementation)
"""
HWID_REGISTRY_PATHS = {
    'system_ids': [
        # Paths for hardware IDs
    ],
    'component_ids': [
        # Paths for specific components
    ]
}


# legacy\src\spoofers\hwid_spoofer\hwid_spoofer.py

# src/spoofers/hwid_spoofer/hwid_spoofer.py

from utils.logger import logger

class HWIDSpoofer:
    def __init__(self):
        logger.info("HWID Spoofer initialized (placeholder).", context="HWID")

    def spoof_hwid(self):
        """Placeholder for HWID spoofing logic."""
        logger.log_info("Executing HWID spoofing (placeholder)...", "HWID")
        # In a real implementation, this would modify HWID-related registry keys.
        # For now, we'll simulate a successful operation.
        logger.log_success("HWID spoofed successfully (placeholder).", "HWID")
        return True


# legacy\src\spoofers\mac_spoofer\mac_paths.py

"""
MAC-specific configurations and paths
"""

VENDOR_OUI = {
    "Cisco": "00:1C:58",
    "Dell": "00:1A:A0",
    "HP": "00:1A:4B",
    "Intel": "00:1B:21",
    "Apple": "00:1D:4F",
    "Samsung": "00:1E:7D",
    "Microsoft": "00:1D:60",
    "Realtek": "00:1E:68",
    "TP-Link": "00:1D:0F",
    "ASUS": "00:1A:92"
}

MAC_REGISTRY_BASE = r"SYSTEM\CurrentControlSet\Control\Class\{4d36e972-e325-11ce-bfc1-08002be10318}"

NETWORK_INTERFACE_PATHS = {
    'registry_locations': [
        # Placeholder for future registry paths related to network interfaces
    ],
    'system_locations': [
        # Placeholder for future system paths for network configurations
    ]
}


# legacy\src\spoofers\mac_spoofer\mac_spoofer.py

# src/spoofers/mac_spoofer/mac_spoofer.py

import subprocess
import re
import random
import winreg
from utils.registry_checker import RegistryChecker
import time
import os
import platform
import ctypes
import sys
sys.path.append(os.path.join(os.path.dirname(__file__), '../..'))
from utils.logger import logger
from .mac_paths import VENDOR_OUI, MAC_REGISTRY_BASE

def is_admin():
    try:
        return ctypes.windll.shell32.IsUserAnAdmin()
    except:
        return False

class MACSpoofer:
    def __init__(self, registry_checker: RegistryChecker = None):
        if platform.system() != 'Windows':
            raise OSError("MAC spoofing only supported on Windows")
            
        if not is_admin():
            raise PermissionError("Administrator privileges required")
            
        self.current_interface = None
        self.original_interface_data = {}
        # Registry helper (injectable for testing)
        self.registry = registry_checker or RegistryChecker()
        
        # Vendor OUIs para endere√ßos MAC realistas
        self.VENDOR_OUI = VENDOR_OUI
        self.registry_base = MAC_REGISTRY_BASE

    def get_interfaces(self):
        interfaces = []
        try:
            # Usa getmac com codifica√ß√£o cp850 (Windows console default)
            output = subprocess.check_output("getmac /v /fo csv", shell=True, encoding='cp850')
            
            # Pula a linha de cabe√ßalho
            lines = output.strip().split('\n')[1:]
            
            for line in lines:
                try:
                    # Remove aspas e divide campos
                    fields = line.strip('"').split('","')
                    
                    if len(fields) >= 3:
                        iface = {
                            'name': fields[0],
                            'description': fields[1],
                            'mac_address': fields[2].strip('"'),
                            'enabled': True  # getmac s√≥ mostra interfaces ativas
                        }
                        interfaces.append(iface)
                        logger.log_info(f"Found interface: {iface['name']} ({iface['mac_address']})", "MAC")
                except IndexError:
                    continue  # Pula linhas malformadas
                    
        except subprocess.CalledProcessError:
            logger.log_error("Failed to get network interfaces - Access denied", "MAC")
            raise PermissionError("Access denied when getting network interfaces")
        except Exception as e:
            # Tenta m√©todo alternativo usando wmic
            try:
                logger.log_info("Trying alternative method with wmic...", "MAC")
                output = subprocess.check_output("wmic nic get Name,MACAddress /format:csv", 
                                              shell=True, encoding='cp850')
                
                lines = output.strip().split('\n')[1:]  # Pula cabe√ßalho
                for line in lines:
                    if ',' not in line:
                        continue
                        
                    name, mac = line.strip().split(',', 1)
                    if mac and mac.strip():  # S√≥ adiciona se tiver MAC
                        iface = {
                            'name': name,
                            'description': name,
                            'mac_address': mac.strip().replace(':', '-'),
                            'enabled': True
                        }
                        interfaces.append(iface)
                        logger.log_info(f"Found interface: {iface['name']} ({iface['mac_address']})", "MAC")
                        
            except Exception as e2:
                logger.log_error(f"Both methods failed to get interfaces: {str(e2)}", "MAC")
                raise RuntimeError(f"Failed to enumerate network interfaces: {str(e2)}")
        
        if not interfaces:
            logger.log_warning("No network interfaces found", "MAC")
            
        return interfaces

    def spoof_mac_address(self, interface_name, vendor_name="", new_mac=None):
        try:
            logger.log_info(f"Starting MAC spoofing for {interface_name}", "MAC")
            
            # Verifica se interface existe
            current_mac = self.get_current_mac(interface_name)
            if not current_mac:
                logger.log_error(f"Interface {interface_name} not found", "MAC")
                return False
                
            if not self.current_interface:
                # Salva MAC original
                self.original_interface_data[interface_name] = current_mac
                logger.log_info(f"Original MAC saved: {current_mac}", "MAC")
            
            self.current_interface = interface_name
            
            # Gera novo MAC
            if not new_mac:
                if vendor_name in self.VENDOR_OUI:
                    new_mac = self._generate_vendor_mac(vendor_name)
                else:
                    new_mac = self._generate_random_mac()
            
            # Desativa interface
            if not self._disable_interface(interface_name):
                logger.log_error(f"Failed to disable interface {interface_name}", "MAC")
                return False
            
            # Define novo MAC - Tenta m√©todo do registro primeiro
            logger.log_info(f"Attempting registry method for {interface_name}", "MAC")
            registry_success = self._set_registry_mac(interface_name, new_mac)
            
            if not registry_success:
                logger.log_warning(f"Registry method failed, trying PowerShell method for {interface_name}", "MAC")
                # Fallback para m√©todo PowerShell
                powershell_success = self._set_mac_powershell(interface_name, new_mac)
                if not powershell_success:
                    logger.log_error(f"All MAC spoofing methods failed for {interface_name}", "MAC")
                    self._enable_interface(interface_name)
                    return False
            
            # Reativa interface
            if not self._enable_interface(interface_name):
                logger.log_error(f"Failed to enable interface {interface_name}", "MAC")
                return False
            
            # Verifica mudan√ßa
            time.sleep(3)  # Aumenta o tempo de espera para Windows 11
            current_mac = self.get_current_mac(interface_name)
            
            if current_mac and current_mac.upper() == new_mac.upper():
                logger.log_success(f"MAC spoofing successful! New MAC: {current_mac}", "MAC")
                return True
            else:
                logger.log_warning(f"MAC verification failed. Current: {current_mac}, Expected: {new_mac}", "MAC")
                # Mesmo com falha na verifica√ß√£o, pode ter funcionado
                return True
                
        except Exception as e:
            logger.log_error(f"Error spoofing MAC: {str(e)}", "MAC")
            # Tenta reativar a interface em caso de erro
            try:
                self._enable_interface(interface_name)
            except:
                pass
            return False

    def reset_mac_address(self, interface_name):
        try:
            logger.log_info(f"Resetting MAC address for {interface_name}", "MAC")
            
            if not self._disable_interface(interface_name):
                return False
                
            # Remove chave do registro para resetar MAC
            interface_guid = self._get_interface_guid(interface_name)
            if interface_guid:
                key_path = f"{self.registry_base}\\{interface_guid}"
                try:
                    # Use RegistryChecker to delete the NetworkAddress value (with backup)
                    self.registry.delete_value("HKLM", key_path, "NetworkAddress", backup=True)
                    logger.log_info(f"Registry MAC value deleted for {interface_name}", "MAC")
                except Exception:
                    logger.log_info(f"No registry MAC value to delete for {interface_name}", "MAC")
                    pass  # Chave pode n√£o existir
            
            # Tenta reset via PowerShell tamb√©m
            try:
                self._reset_mac_powershell(interface_name)
            except Exception as e:
                logger.log_warning(f"PowerShell reset failed: {str(e)}", "MAC")
            
            if not self._enable_interface(interface_name):
                return False
                
            time.sleep(3)  # Aumenta tempo de espera
            logger.log_success(f"MAC reset completed for {interface_name}", "MAC")
            
            if interface_name in self.original_interface_data:
                del self.original_interface_data[interface_name]
            if self.current_interface == interface_name:
                self.current_interface = None
                
            return True
            
        except Exception as e:
            logger.log_error(f"Error resetting MAC: {str(e)}", "MAC")
            return False

    def get_current_mac(self, interface_name):
        try:
            # M√©todo mais robusto para obter MAC
            output = subprocess.check_output('getmac /v /fo csv /nh', shell=True, encoding='cp850')
            for line in output.split('\n'):
                if line.strip() and interface_name in line:
                    fields = line.strip('"').split('","')
                    if len(fields) >= 3 and fields[0] == interface_name:
                        mac = fields[2].strip('"').replace('-', ':').upper()
                        logger.log_info(f"Current MAC for {interface_name}: {mac}", "MAC")
                        return mac
            
            # Fallback: tenta com wmic
            try:
                output = subprocess.check_output(f'wmic nic where "NetConnectionID=\'{interface_name}\'" get MACAddress /format:csv', 
                                              shell=True, encoding='cp850')
                lines = output.strip().split('\n')
                if len(lines) > 1:
                    mac = lines[1].split(',')[-1].strip().replace(':', '').upper()
                    if mac and len(mac) == 12:
                        formatted_mac = ':'.join([mac[i:i+2] for i in range(0, 12, 2)])
                        logger.log_info(f"Current MAC (wmic) for {interface_name}: {formatted_mac}", "MAC")
                        return formatted_mac
            except:
                pass
                
        except Exception as e:
            logger.log_error(f"Error getting current MAC: {str(e)}", "MAC")
        return None
        
    def _disable_interface(self, interface_name):
        try:
            logger.log_info(f"Disabling interface: {interface_name}", "MAC")
            result = subprocess.run(
                f'netsh interface set interface "{interface_name}" disable', 
                shell=True, 
                check=True,
                capture_output=True,
                text=True,
                timeout=30
            )
            time.sleep(2)  # Aumenta tempo de espera
            logger.log_success(f"Interface {interface_name} disabled", "MAC")
            return True
        except subprocess.TimeoutExpired:
            logger.log_error(f"Timeout disabling interface {interface_name}", "MAC")
            return False
        except Exception as e:
            logger.log_error(f"Failed to disable interface {interface_name}: {str(e)}", "MAC")
            return False
            
    def _enable_interface(self, interface_name):
        try:
            logger.log_info(f"Enabling interface: {interface_name}", "MAC")
            result = subprocess.run(
                f'netsh interface set interface "{interface_name}" enable', 
                shell=True, 
                check=True,
                capture_output=True,
                text=True,
                timeout=30
            )
            time.sleep(2)  # Aumenta tempo de espera
            logger.log_success(f"Interface {interface_name} enabled", "MAC")
            return True
        except subprocess.TimeoutExpired:
            logger.log_error(f"Timeout enabling interface {interface_name}", "MAC")
            return False
        except Exception as e:
            logger.log_error(f"Failed to enable interface {interface_name}: {str(e)}", "MAC")
            return False
            
    def _generate_random_mac(self):
        # Gera MAC com bit "locally administered" setado
        mac = ["02"]  # Primeiro byte com bit local setado
        for i in range(5):
            mac.append(f"{random.randint(0, 255):02x}")
        generated_mac = ":".join(mac).upper()
        logger.log_info(f"Generated random MAC: {generated_mac}", "MAC")
        return generated_mac
        
    def _generate_vendor_mac(self, vendor_name):
        vendor_prefix = self.VENDOR_OUI.get(vendor_name, "")
        if not vendor_prefix:
            return self._generate_random_mac()
            
        # Usa OUI do vendor e gera 3 bytes aleat√≥rios
        mac = vendor_prefix.split(":")
        for i in range(3):
            mac.append(f"{random.randint(0, 255):02x}")
        generated_mac = ":".join(mac).upper()
        logger.log_info(f"Generated vendor MAC ({vendor_name}): {generated_mac}", "MAC")
        return generated_mac
        
    def _get_interface_guid(self, interface_name):
        """M√©todo melhorado para encontrar o GUID da interface no Windows 11"""
        try:
            logger.log_info(f"Searching for GUID of interface: {interface_name}", "MAC")
            
            # M√©todo 1: Usa PowerShell para obter o InterfaceGuid diretamente
            try:
                ps_cmd = f"Get-NetAdapter -Name '{interface_name}' | Select-Object -ExpandProperty InterfaceGuid"
                output = subprocess.check_output(["powershell", "-Command", ps_cmd], 
                                              shell=False, 
                                              encoding='cp850',
                                              timeout=15)
                guid = output.strip()
                if guid:
                    logger.log_info(f"Found GUID via PowerShell: {guid}", "MAC")
                    # Agora procura o n√∫mero correspondente no registro usando RegistryChecker
                    try:
                        sub = self.registry.find_subkey_by_value("HKLM", self.registry_base, "NetCfgInstanceId", lambda v: isinstance(v, str) and v.lower() == guid.lower())
                        if sub:
                            logger.log_info(f"Found registry key: {sub} for GUID: {guid}", "MAC")
                            return sub
                    except Exception:
                        logger.log_warning("Error searching registry for GUID via RegistryChecker", "MAC")
            except subprocess.CalledProcessError as e:
                logger.log_warning(f"PowerShell method failed: {str(e)}", "MAC")
            except subprocess.TimeoutExpired:
                logger.log_warning("PowerShell command timeout", "MAC")

            # M√©todo 2: Busca por DriverDesc (mais compat√≠vel)
            logger.log_info("Trying DriverDesc/NetCfgInstanceId method...", "MAC")
            try:
                subs = self.registry.enumerate_subkeys("HKLM", self.registry_base)
                for subkey_name in subs:
                    try:
                        # Try DriverDesc
                        try:
                            driver_desc, _ = self.registry.read_value("HKLM", os.path.join(self.registry_base, subkey_name), "DriverDesc")
                            if driver_desc and interface_name.lower() in str(driver_desc).lower():
                                logger.log_info(f"Found by DriverDesc: {subkey_name} - {driver_desc}", "MAC")
                                return subkey_name
                        except Exception:
                            pass

                        # Try NetCfgInstanceId
                        try:
                            netcfg, _ = self.registry.read_value("HKLM", os.path.join(self.registry_base, subkey_name), "NetCfgInstanceId")
                            if netcfg and interface_name.lower() in str(netcfg).lower():
                                logger.log_info(f"Found by NetCfgInstanceId: {subkey_name} - {netcfg}", "MAC")
                                return subkey_name
                        except Exception:
                            pass
                    except Exception:
                        continue
            except Exception:
                logger.log_warning("Error enumerating network adapter registry keys via RegistryChecker", "MAC")

            # M√©todo 3: Busca por nome correspondente
            logger.log_info("Trying name matching method...", "MAC")
            try:
                subs = self.registry.enumerate_subkeys("HKLM", self.registry_base)
                for subkey_name in subs:
                    if not str(subkey_name).isdigit():
                        continue
                    try:
                        for value_name in ["DriverDesc", "NetCfgInstanceId", "ComponentId"]:
                            try:
                                val, _ = self.registry.read_value("HKLM", os.path.join(self.registry_base, subkey_name), value_name)
                                if val and interface_name.lower() in str(val).lower():
                                    logger.log_info(f"Found by {value_name}: {subkey_name} - {val}", "MAC")
                                    return subkey_name
                            except Exception:
                                continue
                    except Exception:
                        continue
            except Exception:
                logger.log_warning("Error enumerating registry keys in name-matching method", "MAC")

            logger.log_error(f"Could not find GUID for interface: {interface_name}", "MAC")
            return None

        except Exception as e:
            logger.log_error(f"_get_interface_guid error: {str(e)}", "MAC")
            return None
        
    def _set_registry_mac(self, interface_name, new_mac):
        try:
            interface_guid = self._get_interface_guid(interface_name)
            if not interface_guid:
                logger.log_error(f"Could not find registry subkey for interface {interface_name}", "MAC")
                return False

            key_path = f"{self.registry_base}\\{interface_guid}"
            logger.log_info(f"Writing NetworkAddress to registry key: {key_path}", "MAC")
            # Ensure admin
            try:
                self.registry.ensure_admin_or_raise()
            except Exception as e:
                logger.log_error(str(e), "MAC")
                return False

            # Remove caracteres : do MAC para o registro
            mac_value = new_mac.replace(":", "")

            # Use RegistryChecker to write value (it will create backup and respect dry-run)
            try:
                self.registry.write_value("HKLM", key_path, "NetworkAddress", mac_value, value_type=winreg.REG_SZ, backup=True)
            except Exception as e:
                logger.log_error(f"Failed to set registry MAC: {e}", "MAC")
                return False

            logger.log_info(f"Registry NetworkAddress set to {mac_value}", "MAC")

            # Verifica se foi escrito corretamente
            try:
                stored_value, _ = self.registry.read_value("HKLM", key_path, "NetworkAddress")
                if stored_value == mac_value:
                    logger.log_success("Registry value verified successfully", "MAC")
                    return True
                else:
                    logger.log_error(f"Registry verification failed. Stored: {stored_value}, Expected: {mac_value}", "MAC")
                    return False
            except Exception as e:
                logger.log_error(f"Registry verification failed: {e}", "MAC")
                return False

        except PermissionError:
            logger.log_error("Permission denied when writing to registry", "MAC")
            return False
        except Exception as e:
            logger.log_error(f"Failed to set registry MAC: {str(e)}", "MAC")
            return False

    def _set_mac_powershell(self, interface_name, new_mac):
        """M√©todo alternativo usando PowerShell para Windows 11"""
        try:
            logger.log_info(f"Attempting PowerShell method for {interface_name}", "MAC")
            
            # Remove caracteres : do MAC
            mac_value = new_mac.replace(":", "")
            
            # Comando PowerShell para mudar MAC
            ps_command = [
                "powershell", "-Command",
                f"Get-NetAdapter -Name '{interface_name}' | Set-NetAdapter -MACAddress '{mac_value}' -Confirm:$false"
            ]
            
            result = subprocess.run(
                ps_command,
                check=True,
                capture_output=True,
                text=True,
                timeout=30
            )
            
            logger.log_success(f"PowerShell MAC change executed for {interface_name}", "MAC")
            return True
            
        except subprocess.CalledProcessError as e:
            logger.log_error(f"PowerShell command failed: {e.stderr}", "MAC")
            return False
        except subprocess.TimeoutExpired:
            logger.log_error("PowerShell command timeout", "MAC")
            return False
        except Exception as e:
            logger.log_error(f"PowerShell method error: {str(e)}", "MAC")
            return False

    def _reset_mac_powershell(self, interface_name):
        """Reseta MAC usando PowerShell"""
        try:
            logger.log_info(f"Resetting MAC via PowerShell for {interface_name}", "MAC")
            
            ps_command = [
                "powershell", "-Command",
                f"Get-NetAdapter -Name '{interface_name}' | Set-NetAdapter -MACAddress '' -Confirm:$false"
            ]
            
            result = subprocess.run(
                ps_command,
                check=True,
                capture_output=True,
                text=True,
                timeout=30
            )
            
            logger.log_success(f"PowerShell MAC reset executed for {interface_name}", "MAC")
            return True
            
        except Exception as e:
            logger.log_warning(f"PowerShell reset failed: {str(e)}", "MAC")
            return False


# legacy\src\spoofers\mac_spoofer\select_network.py

# src/spoofers/mac_spoofer/select_network.py

import customtkinter as ctk
import os

class InterfaceSelectionDialog:
    def __init__(self, parent, mac_spoofer):
        self.dialog = ctk.CTkToplevel(parent)
        self.dialog.title("Select Network Interface")
        self.dialog.geometry("450x600")
        self.dialog.transient(parent)
        self.dialog.grab_set()
        self.dialog.configure(fg_color="#1a1a1a")
        
        self.mac_spoofer = mac_spoofer
        self.selected_interface = None
        self.selected_vendor = None
        self.new_mac = None
        self.interface_buttons = []

        # Definir √≠cone
        self.set_window_icon()

        self.setup_ui()

    def setup_ui(self):
        # --- Fontes ---
        TITLE_FONT = ctk.CTkFont(family="Roboto", size=20, weight="bold")
        BODY_FONT = ctk.CTkFont(family="Roboto", size=12)
        BUTTON_FONT = ctk.CTkFont(family="Roboto", size=12, weight="bold")

        # --- Frame Principal ---
        main_frame = ctk.CTkFrame(self.dialog, fg_color="#1a1a1a")
        main_frame.pack(fill="both", expand=True, padx=20, pady=20)

        # --- T√≠tulo ---
        title = ctk.CTkLabel(
            main_frame,
            text="Select Network Interface",
            font=TITLE_FONT,
            text_color="#ffffff"
        )
        title.pack(pady=(0, 20))

        # --- Lista de Interfaces ---
        interfaces_frame = ctk.CTkScrollableFrame(
            main_frame,
            fg_color="#2a2a2a",
            border_width=1,
            border_color="#6a0dad"
        )
        interfaces_frame.pack(fill="both", expand=True, pady=10)

        self.interfaces = self.mac_spoofer.get_interfaces()

        for iface in self.interfaces:
            btn = ctk.CTkButton(
                interfaces_frame,
                text=f"{iface['description']}\nMAC: {iface['mac_address']}",
                height=60,
                font=BODY_FONT,
                fg_color="#2a2a2a",
                border_width=2,
                border_color="#2a2a2a",
                hover_color="#5a1f99",
                text_color="#ffffff",
                corner_radius=10
            )
            btn.configure(command=lambda i=iface, b=btn: self.select_interface(i, b))
            btn.pack(fill="x", pady=8, padx=10)
            self.interface_buttons.append(btn)

        # --- Sele√ß√£o de Vendor ---
        vendor_frame = ctk.CTkFrame(main_frame, fg_color="transparent")
        vendor_frame.pack(fill="x", pady=10)

        vendor_label = ctk.CTkLabel(
            vendor_frame,
            text="Select Vendor (Optional):",
            font=BODY_FONT,
            text_color="#ffffff"
        )
        vendor_label.pack(anchor="w", pady=(0, 5))

        vendors = ["Random"] + list(self.mac_spoofer.VENDOR_OUI.keys())
        self.vendor_var = ctk.StringVar(value="Random")

        vendor_menu = ctk.CTkOptionMenu(
            vendor_frame,
            values=vendors,
            variable=self.vendor_var,
            font=BUTTON_FONT,
            fg_color="#6a0dad",
            button_color="#6a0dad",
            button_hover_color="#8a2be2",
            dropdown_fg_color="#2a2a2a",
            dropdown_hover_color="#8a2be2",
            dropdown_text_color="#ffffff",
            text_color="#ffffff",
            corner_radius=8,
            height=40
        )
        vendor_menu.pack(fill="x", expand=True)

        # --- Bot√µes de A√ß√£o ---
        btn_frame = ctk.CTkFrame(main_frame, fg_color="transparent")
        btn_frame.pack(fill="x", pady=20)

        cancel_btn = ctk.CTkButton(
            btn_frame,
            text="Cancel",
            command=self.dialog.destroy,
            font=BUTTON_FONT,
            fg_color="#3a3a3a",
            hover_color="#4a4a4a",
            height=40,
            corner_radius=8
        )
        cancel_btn.pack(side="left", expand=True, padx=(0, 10))

        self.ok_btn = ctk.CTkButton(
            btn_frame,
            text="OK",
            command=self.confirm,
            state="disabled",
            font=BUTTON_FONT,
            fg_color="#6a0dad",
            hover_color="#8a2be2",
            height=40,
            corner_radius=8
        )
        self.ok_btn.pack(side="left", expand=True, padx=(10, 0))

    def set_window_icon(self):
        """Set icon for dialog window"""
        try:
            icon_path = 'app.ico'
            if os.path.exists(icon_path):
                self.dialog.iconbitmap(icon_path)
        except Exception as e:
            print(f"Failed to set dialog icon: {e}")

    def select_interface(self, interface, selected_button):
        self.selected_interface = interface['name']

        for btn in self.interface_buttons:
            if btn == selected_button:
                btn.configure(border_color="#8a2be2", fg_color="#8a2be2", hover_color="#8a2be2")
            else:
                btn.configure(border_color="#2a2a2a", fg_color="#2a2a2a", hover_color="#5a1f99")

        self.ok_btn.configure(state="normal")
    
    def confirm(self):
        vendor = self.vendor_var.get()
        self.selected_vendor = vendor if vendor != "Random" else ""

        # Janela de preview (mantida a l√≥gica, mas pode ser estilizada no futuro)
        preview = ctk.CTkToplevel(self.dialog)
        preview.title("Preview Registry Change")
        preview.geometry("400x250")
        preview.transient(self.dialog)
        preview.grab_set()
        preview.configure(fg_color="#1a1a1a")

        iface = next((i for i in self.interfaces if i['name'] == self.selected_interface), None)
        if iface is None:
            preview.destroy()
            self.dialog.destroy()
            return

        if self.selected_vendor:
            self.new_mac = self.mac_spoofer._generate_vendor_mac(self.selected_vendor)
        else:
            self.new_mac = self.mac_spoofer._generate_random_mac()

        key_path = f"SYSTEM\\...\\{{4d36e972-e325-11ce-bfc1-08002be10318}}\\<GUID>"

        ctk.CTkLabel(preview, text=f"Interface: {self.selected_interface}", anchor="w", text_color="#ffffff").pack(fill="x", padx=15, pady=(15, 5))
        ctk.CTkLabel(preview, text=f"New MAC (Preview): {self.new_mac}", anchor="w", text_color="#ffffff").pack(fill="x", padx=15, pady=5)
        ctk.CTkLabel(preview, text=f"Registry Key (Target): {key_path}", anchor="w", wraplength=370, text_color="#ffffff").pack(fill="x", padx=15, pady=5)

        btn_frame2 = ctk.CTkFrame(preview, fg_color="transparent")
        btn_frame2.pack(fill="x", padx=15, pady=20)

        cancel = ctk.CTkButton(btn_frame2, text="Cancel", command=preview.destroy, fg_color="#3a3a3a", hover_color="#4a4a4a")
        cancel.pack(side="left", expand=True, padx=(0, 5))

        apply_btn = ctk.CTkButton(btn_frame2, text="Apply", command=lambda: (preview.destroy(), self.dialog.destroy()), fg_color="#6a0dad", hover_color="#8a2be2")
        apply_btn.pack(side="left", expand=True, padx=(5, 0))
    
    def show(self):
        self.dialog.wait_window()
        return self.selected_interface, self.selected_vendor, self.new_mac


# legacy\src\utils\hardware_reader.py

# src/utils/hardware_reader.py

import wmi
import psutil
import platform
import uuid
import re
import winreg
import subprocess
import json
import hashlib
import os
import tempfile
import time
from typing import Dict, Optional

class HardwareReader:
    def __init__(self):
        # WMI availability checking
        try:
            self.c = wmi.WMI()
            self.wmi_available = True
            from src.utils.logger import logger
            logger.log_info("WMI inicializado com sucesso", "HARDWARE_READER")
        except Exception as e:
            self.c = None
            self.wmi_available = False
            from src.utils.logger import logger
            logger.log_warning(f"WMI n√£o dispon√≠vel - usando m√©todos alternativos: {str(e)}", "HARDWARE_READER")

        # Cache attributes
        self.cache_file = os.path.join(tempfile.gettempdir(), "midnight_spoofer_cache.json")
        self.cache_timeout = 300  # 5 minutes
        self.last_cache_time = 0
        self.cached_data = None
    
    def get_all_hardware_ids(self):
        """Coleta todos os IDs de hardware reais"""
        try:
            hardware = {}
            
            # Disk Serial (C: and D: drives)
            hardware['disk_c'] = self._get_disk_serial('C:')
            hardware['disk_d'] = self._get_disk_serial('D:')
            
            # Motherboard
            hardware['motherboard'] = self._get_motherboard_serial()
            
            # SMBIOS UUID
            hardware['smbios_uuid'] = self._get_uuid()
            
            # Chassis
            hardware['chassis'] = self._get_chassis_serial()
            
            # BIOS
            hardware['bios'] = self._get_bios_serial()
            
            # CPU
            hardware['cpu'] = self._get_cpu_id()
            
            # MAC Address
            hardware['mac'] = self._get_mac_address()
            
            return hardware
        except Exception as e:
            print(f"Error reading hardware: {e}")
            return self._get_fallback_data()
    
    def _get_disk_serial(self, drive_letter):
        try:
            for disk in self.c.Win32_LogicalDisk(DeviceID=drive_letter):
                if disk.VolumeSerialNumber:
                    return disk.VolumeSerialNumber
        except:
            pass
        return "N/A"
    
    def _get_motherboard_serial(self):
        try:
            for board in self.c.Win32_BaseBoard():
                if board.SerialNumber:
                    return board.SerialNumber.strip()
        except:
            pass
        return "N/A"
    
    def _get_uuid(self):
        try:
            for item in self.c.Win32_ComputerSystemProduct():
                if item.UUID:
                    return item.UUID
        except:
            pass
        return str(uuid.uuid4())
    
    def _get_chassis_serial(self):
        try:
            for chassis in self.c.Win32_SystemEnclosure():
                if chassis.SerialNumber:
                    return chassis.SerialNumber.strip()
        except:
            pass
        return "N/A"
    
    def _get_bios_serial(self):
        try:
            for bios in self.c.Win32_BIOS():
                if bios.SerialNumber:
                    return bios.SerialNumber.strip()
        except:
            pass
        return "N/A"
    
    def _get_cpu_id(self):
        try:
            for cpu in self.c.Win32_Processor():
                if cpu.ProcessorId:
                    return cpu.ProcessorId.strip()
        except:
            pass
        return "N/A"
    
    def _get_mac_address(self):
        try:
            for nic in self.c.Win32_NetworkAdapterConfiguration(IPEnabled=True):
                if nic.MACAddress:
                    return nic.MACAddress.replace(':', '')
        except:
            pass
        # Fallback usando uuid
        mac = ':'.join(re.findall('..', '%012x' % uuid.getnode()))
        return mac.replace(':', '')
    
    def _get_fallback_data(self):
        """Dados de fallback caso WMI falhe"""
        return {
            'disk_c': "N/A",
            'disk_d': "N/A",
            'motherboard': "N/A",
            'smbios_uuid': str(uuid.uuid4()),
            'chassis': "N/A",
            'bios': "N/A",
            'cpu': "N/A",
            'mac': ':'.join(re.findall('..', '%012x' % uuid.getnode())).replace(':', '')
        }

    def get_formatted_hardware_data(self, mac_spoofer=None):
        """
        Obt√©m e formata os dados de hardware para exibi√ß√£o na UI.
        Opcionalmente, verifica se h√° um MAC spoofado ativo.
        """
        if not self:
            return {
                'disk_c': 'N/A', 'disk_d': 'N/A', 'motherboard': 'N/A',
                'smbios_uuid': 'N/A', 'chassis': 'N/A', 'bios': 'N/A',
                'cpu': 'N/A', 'mac': 'N/A'
            }
        
        try:
            hw_data = self.get_all_hardware_ids()
            
            # Se um spoofer de MAC for fornecido e houver um MAC spoofado, atualiza o valor
            if mac_spoofer and mac_spoofer.current_interface and \
               mac_spoofer.current_interface in mac_spoofer.original_interface_data:
                current_mac = mac_spoofer.get_current_mac(mac_spoofer.current_interface)
                if current_mac:
                    hw_data['mac'] = f"{current_mac} üé≠"
            
            return hw_data
        except Exception as e:
            # Em caso de erro, retorna dados de fallback para n√£o quebrar a UI
            print(f"Error getting formatted hardware data: {e}")
            return self._get_fallback_data()

    def _get_windows_activation_status(self) -> str:
        """
        Detecta o status de ativa√ß√£o do Windows usando m√∫ltiplos m√©todos.
        Retorna: "Ativado", "N√£o Ativado", "Expirou", "Erro", "Status Desconhecido"
        """
        from src.utils.logger import logger

        # M√©todo 1: SLMGR (mais confi√°vel) - usando caminho completo
        try:
            logger.log_info("Tentando detectar ativa√ß√£o via SLMGR", "WINDOWS_ACTIVATION")
            slmgr_path = r"C:\Windows\System32\slmgr.vbs"
            result = subprocess.run(
                ['cscript', slmgr_path, '/xpr'],
                capture_output=True,
                text=True,
                timeout=15,
                creationflags=subprocess.CREATE_NO_WINDOW
            )

            output = result.stdout.lower()
            # Verificar tanto portugu√™s quanto ingl√™s
            if ("permanentemente" in output or "permanently" in output or
                "ativado" in output or "activated" in output or "licenciado" in output):
                logger.log_success("Windows detectado como ativado via SLMGR", "WINDOWS_ACTIVATION")
                return "Ativado"
            elif "expired" in output or "expirou" in output or "expirada" in output:
                logger.log_warning("Windows detectado como expirado via SLMGR", "WINDOWS_ACTIVATION")
                return "Expirou"
            else:
                logger.log_info(f"SLMGR output n√£o reconhecido: {output[:100]}", "WINDOWS_ACTIVATION")

        except subprocess.TimeoutExpired:
            logger.log_warning("SLMGR timeout - m√©todo alternativo ser√° usado", "WINDOWS_ACTIVATION")
        except FileNotFoundError:
            logger.log_warning("SLMGR n√£o encontrado no sistema", "WINDOWS_ACTIVATION")
        except Exception as e:
            logger.log_error(f"Erro ao executar SLMGR: {str(e)}", "WINDOWS_ACTIVATION")

        # M√©todo 2: Registry - m√∫ltiplas chaves
        registry_paths = [
            r"SOFTWARE\Microsoft\Windows NT\CurrentVersion\SoftwareProtectionPlatform",
            r"SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsActivationTechnologies\LicensingState"
        ]

        for reg_path in registry_paths:
            try:
                logger.log_info(f"Tentando detectar ativa√ß√£o via Registry: {reg_path}", "WINDOWS_ACTIVATION")
                with winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, reg_path, 0, winreg.KEY_READ) as key:
                    # Tentar diferentes valores dependendo da chave
                    if "SoftwareProtectionPlatform" in reg_path:
                        license_status, _ = winreg.QueryValueEx(key, "LicenseStatus")
                        if license_status == 1:
                            logger.log_success("Windows detectado como ativado via Registry (SPP)", "WINDOWS_ACTIVATION")
                            return "Ativado (Registry)"
                        elif license_status == 0:
                            logger.log_info("Windows detectado como n√£o ativado via Registry (SPP)", "WINDOWS_ACTIVATION")
                            return "N√£o Ativado"
                    elif "LicensingState" in reg_path:
                        licensing_state, _ = winreg.QueryValueEx(key, "LicensingState")
                        # LicensingState: bit 0 = licensed, bit 1 = activated
                        if licensing_state & 1:  # Bit 0 set = licensed
                            logger.log_success("Windows detectado como ativado via Registry (LicensingState)", "WINDOWS_ACTIVATION")
                            return "Ativado (Registry)"
                        else:
                            logger.log_info("Windows detectado como n√£o ativado via Registry (LicensingState)", "WINDOWS_ACTIVATION")
                            return "N√£o Ativado"
            except FileNotFoundError:
                continue  # Tentar pr√≥xima chave
            except Exception as e:
                logger.log_error(f"Erro ao ler registro {reg_path}: {str(e)}", "WINDOWS_ACTIVATION")
                continue

        logger.log_info("Chaves de registro de ativa√ß√£o n√£o encontradas ou inacess√≠veis", "WINDOWS_ACTIVATION")

        # M√©todo 3: WMI - verifica√ß√£o mais robusta
        if self.wmi_available:
            try:
                logger.log_info("Tentando detectar ativa√ß√£o via WMI", "WINDOWS_ACTIVATION")
                for os_info in self.c.Win32_OperatingSystem():
                    if hasattr(os_info, 'LicenseStatus') and os_info.LicenseStatus is not None:
                        if os_info.LicenseStatus == 1:  # Licensed
                            logger.log_success("Windows detectado como ativado via WMI (LicenseStatus)", "WINDOWS_ACTIVATION")
                            return "Ativado (WMI)"
                        elif os_info.LicenseStatus == 0:  # Unlicensed
                            logger.log_info("Windows detectado como n√£o ativado via WMI", "WINDOWS_ACTIVATION")
                            return "N√£o Ativado"
                    # Verificar ProductType para Windows genu√≠no
                    if hasattr(os_info, 'ProductType') and os_info.ProductType == 1:  # Client OS
                        # Verificar se h√° chave de produto v√°lida
                        if hasattr(os_info, 'SerialNumber') and os_info.SerialNumber:
                            logger.log_success("Windows detectado como ativado via WMI (ProductType)", "WINDOWS_ACTIVATION")
                            return "Ativado (WMI)"
            except Exception as e:
                logger.log_error(f"Erro ao verificar WMI para ativa√ß√£o: {str(e)}", "WINDOWS_ACTIVATION")

        logger.log_warning("Status de ativa√ß√£o do Windows n√£o p√¥de ser determinado", "WINDOWS_ACTIVATION")
        return "Status Desconhecido"

    def _get_installation_id(self) -> str:
        """
        Gera um Installation ID √∫nico baseado em hardware + software.
        Formato: WIN-{SHA256 hash em mai√∫sculo}
        """
        from src.utils.logger import logger

        try:
            logger.log_info("Gerando Installation ID", "INSTALLATION_ID")

            # Coleta dados do sistema para gerar hash √∫nico
            system_data = {}

            # Machine GUID
            try:
                with winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, r"SOFTWARE\Microsoft\Cryptography", 0, winreg.KEY_READ) as key:
                    system_data['machine_guid'] = winreg.QueryValueEx(key, "MachineGuid")[0]
            except:
                system_data['machine_guid'] = str(uuid.uuid4())

            # Product ID
            try:
                with winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, r"SOFTWARE\Microsoft\Windows NT\CurrentVersion", 0, winreg.KEY_READ) as key:
                    system_data['product_id'] = winreg.QueryValueEx(key, "ProductId")[0]
            except:
                system_data['product_id'] = platform.version()

            # Computer name e Windows edition
            system_data['computer_name'] = platform.node()
            system_data['windows_edition'] = platform.version()

            # Hardware identifiers
            hw_data = self.get_all_hardware_ids()
            system_data['motherboard'] = hw_data.get('motherboard', 'N/A')
            system_data['bios'] = hw_data.get('bios', 'N/A')
            system_data['cpu'] = hw_data.get('cpu', 'N/A')

            # Gera hash √∫nico
            hash_input = json.dumps(system_data, sort_keys=True).encode('utf-8')
            installation_hash = hashlib.sha256(hash_input).hexdigest()[:16].upper()

            installation_id = f"WIN-{installation_hash}"
            logger.log_success(f"Installation ID gerado: {installation_id}", "INSTALLATION_ID")
            return installation_id

        except Exception as e:
            logger.log_error(f"Erro ao gerar Installation ID: {str(e)}", "INSTALLATION_ID")
            # Fallback: gerar ID baseado no erro
            error_hash = hashlib.md5(str(e).encode()).hexdigest()[:8].upper()
            return f"ERR-{error_hash}"

    def _cache_software_ids(self, data: Dict[str, str]) -> None:
        """
        Cache em arquivo tempor√°rio para performance.
        Invalida cache se hardware mudar significativamente.
        """
        try:
            from src.utils.logger import logger

            # Adiciona timestamp e dados de hardware para valida√ß√£o
            cache_data = {
                'timestamp': time.time(),
                'hardware_fingerprint': self._get_hardware_fingerprint(),
                'data': data
            }

            with open(self.cache_file, 'w', encoding='utf-8') as f:
                json.dump(cache_data, f, ensure_ascii=False, indent=2)

            logger.log_info("Dados de software cached com sucesso", "CACHE")

        except Exception as e:
            from src.utils.logger import logger
            logger.log_error(f"Erro ao salvar cache: {str(e)}", "CACHE")

    def _load_cached_software_ids(self) -> Optional[Dict[str, str]]:
        """
        Carrega dados cached se ainda v√°lidos.
        """
        try:
            if not os.path.exists(self.cache_file):
                return None

            with open(self.cache_file, 'r', encoding='utf-8') as f:
                cache_data = json.load(f)

            # Verifica timeout
            if time.time() - cache_data['timestamp'] > self.cache_timeout:
                from src.utils.logger import logger
                logger.log_info("Cache expirado", "CACHE")
                return None

            # Verifica se hardware mudou significativamente
            current_fingerprint = self._get_hardware_fingerprint()
            if cache_data['hardware_fingerprint'] != current_fingerprint:
                from src.utils.logger import logger
                logger.log_info("Hardware mudou - invalidando cache", "CACHE")
                return None

            from src.utils.logger import logger
            logger.log_info("Dados carregados do cache", "CACHE")
            return cache_data['data']

        except Exception as e:
            from src.utils.logger import logger
            logger.log_error(f"Erro ao carregar cache: {str(e)}", "CACHE")
            return None

    def _get_hardware_fingerprint(self) -> str:
        """
        Gera fingerprint do hardware para validar cache.
        """
        try:
            hw_data = self.get_all_hardware_ids()
            fingerprint_data = {
                'motherboard': hw_data.get('motherboard', ''),
                'bios': hw_data.get('bios', ''),
                'cpu': hw_data.get('cpu', ''),
                'smbios_uuid': hw_data.get('smbios_uuid', '')
            }
            return hashlib.md5(json.dumps(fingerprint_data, sort_keys=True).encode()).hexdigest()
        except:
            return "fingerprint_error"

    def _get_software_identifiers_safe(self) -> Dict[str, str]:
        """
        Vers√£o robusta com fallback gradativo para coleta de identificadores de software:
        1. Tenta m√©todo principal
        2. Tenta m√©todo alternativo
        3. Usa valores cached se dispon√≠vel
        4. Fallback para valores gerados
        """
        from src.utils.logger import logger

        start_time = time.time()
        logger.log_info("Iniciando coleta segura de identificadores de software", "SOFTWARE_IDS")

        # Tenta carregar do cache primeiro
        cached_data = self._load_cached_software_ids()
        if cached_data:
            logger.log_success("Dados carregados do cache", "SOFTWARE_IDS")
            return cached_data

        software_ids = {}

        # Windows MachineGuid
        try:
            logger.log_info("Coletando Machine GUID", "SOFTWARE_IDS")
            with winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, r"SOFTWARE\Microsoft\Cryptography", 0, winreg.KEY_READ) as key:
                software_ids['machine_guid'] = winreg.QueryValueEx(key, "MachineGuid")[0]
            logger.log_success("Machine GUID coletado com sucesso", "SOFTWARE_IDS")
        except FileNotFoundError:
            software_ids['machine_guid'] = "N√£o Encontrado"
            logger.log_warning("Machine GUID n√£o encontrado no registro", "SOFTWARE_IDS")
        except PermissionError:
            software_ids['machine_guid'] = "Sem Permiss√£o"
            logger.log_error("Sem permiss√£o para ler Machine GUID", "SOFTWARE_IDS")
        except Exception as e:
            software_ids['machine_guid'] = f"Erro: {str(e)[:50]}"
            logger.log_error(f"Erro ao coletar Machine GUID: {str(e)}", "SOFTWARE_IDS")

        # Windows ProductId
        try:
            logger.log_info("Coletando Product ID", "SOFTWARE_IDS")
            with winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, r"SOFTWARE\Microsoft\Windows NT\CurrentVersion", 0, winreg.KEY_READ) as key:
                software_ids['product_id'] = winreg.QueryValueEx(key, "ProductId")[0]
            logger.log_success("Product ID coletado com sucesso", "SOFTWARE_IDS")
        except FileNotFoundError:
            software_ids['product_id'] = "N√£o Encontrado"
            logger.log_warning("Product ID n√£o encontrado no registro", "SOFTWARE_IDS")
        except PermissionError:
            software_ids['product_id'] = "Sem Permiss√£o"
            logger.log_error("Sem permiss√£o para ler Product ID", "SOFTWARE_IDS")
        except Exception as e:
            software_ids['product_id'] = f"Erro: {str(e)[:50]}"
            logger.log_error(f"Erro ao coletar Product ID: {str(e)}", "SOFTWARE_IDS")

        # Rockstar Games GUID
        try:
            logger.log_info("Coletando Rockstar GUID", "SOFTWARE_IDS")
            with winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, r"SOFTWARE\Rockstar Games", 0, winreg.KEY_READ) as key:
                software_ids['rockstar_guid'] = winreg.QueryValueEx(key, "GUID")[0]
            logger.log_success("Rockstar GUID coletado com sucesso", "SOFTWARE_IDS")
        except FileNotFoundError:
            software_ids['rockstar_guid'] = "N√£o Instalado"
            logger.log_info("Rockstar Games n√£o instalado", "SOFTWARE_IDS")
        except PermissionError:
            software_ids['rockstar_guid'] = "Sem Permiss√£o"
            logger.log_error("Sem permiss√£o para ler Rockstar GUID", "SOFTWARE_IDS")
        except Exception as e:
            software_ids['rockstar_guid'] = f"Erro: {str(e)[:50]}"
            logger.log_error(f"Erro ao coletar Rockstar GUID: {str(e)}", "SOFTWARE_IDS")

        # FiveM GUID (m√∫ltiplas localiza√ß√µes)
        fivem_guid = "N√£o Instalado"
        fivem_locations = [
            (winreg.HKEY_CURRENT_USER, r"Software\Cfx.re"),
            (winreg.HKEY_CURRENT_USER, r"Software\CitizenFX"),
            (winreg.HKEY_LOCAL_MACHINE, r"SOFTWARE\CitizenFX")
        ]

        for hive, path in fivem_locations:
            try:
                logger.log_info(f"Verificando FiveM em {path}", "SOFTWARE_IDS")
                with winreg.OpenKey(hive, path, 0, winreg.KEY_READ) as key:
                    fivem_guid = winreg.QueryValueEx(key, "guid")[0] if path == r"Software\Cfx.re" else winreg.QueryValueEx(key, "GUID")[0]
                logger.log_success(f"FiveM GUID encontrado em {path}", "SOFTWARE_IDS")
                break
            except FileNotFoundError:
                continue
            except Exception as e:
                logger.log_error(f"Erro ao verificar FiveM em {path}: {str(e)}", "SOFTWARE_IDS")
                continue

        software_ids['fivem_guid'] = fivem_guid

        # Windows Activation
        try:
            logger.log_info("Detectando status de ativa√ß√£o do Windows", "SOFTWARE_IDS")
            software_ids['windows_activation'] = self._get_windows_activation_status()
        except Exception as e:
            software_ids['windows_activation'] = "Erro na Detec√ß√£o"
            logger.log_error(f"Erro ao detectar ativa√ß√£o do Windows: {str(e)}", "SOFTWARE_IDS")

        # Installation ID
        try:
            logger.log_info("Gerando Installation ID", "SOFTWARE_IDS")
            software_ids['installation_id'] = self._get_installation_id()
        except Exception as e:
            software_ids['installation_id'] = f"ERR-{hashlib.md5(str(e).encode()).hexdigest()[:8]}"
            logger.log_error(f"Erro ao gerar Installation ID: {str(e)}", "SOFTWARE_IDS")

        # Cache os resultados
        self._cache_software_ids(software_ids)

        elapsed_time = time.time() - start_time
        logger.log_success(f"Coleta de identificadores conclu√≠da em {elapsed_time:.2f}s", "SOFTWARE_IDS")

        return software_ids

    def get_software_identifiers(self):
        """
        Coleta todos os identificadores de software do sistema usando m√©todo seguro.
        Mant√©m compatibilidade com interface existente.
        """
        try:
            return self._get_software_identifiers_safe()
        except Exception as e:
            from src.utils.logger import logger
            logger.log_error(f"Erro cr√≠tico na coleta de identificadores: {str(e)}", "SOFTWARE_IDS")
            # Fallback final para manter compatibilidade
            return {
                'machine_guid': 'Erro Cr√≠tico',
                'product_id': 'Erro Cr√≠tico',
                'rockstar_guid': 'Erro Cr√≠tico',
                'fivem_guid': 'Erro Cr√≠tico',
                'windows_activation': 'Erro Cr√≠tico',
                'installation_id': 'Erro Cr√≠tico'
            }

    def get_comprehensive_hardware_data(self, mac_spoofer=None):
        """
        Obt√©m dados completos de hardware + GUIDs do sistema
        """
        hw_data = self.get_formatted_hardware_data(mac_spoofer)
        software_ids = self.get_software_identifiers()
        
        # Combina ambos os datasets
        comprehensive_data = {**hw_data, **software_ids}
        return comprehensive_data


# legacy\src\utils\icon_manager.py

import os
import ctypes
from ctypes import wintypes

class IconManager:
    @staticmethod
    def set_taskbar_icon(root, icon_path):
        """Force set taskbar icon for CustomTkinter windows"""
        try:
            if os.name == 'nt' and os.path.exists(icon_path):
                # Get window handle
                hwnd = ctypes.windll.user32.GetParent(root.winfo_id())

                # Ensure window appears in taskbar
                GWL_EXSTYLE = -20
                WS_EX_APPWINDOW = 0x00040000
                style = ctypes.windll.user32.GetWindowLongW(hwnd, GWL_EXSTYLE)
                ctypes.windll.user32.SetWindowLongW(hwnd, GWL_EXSTYLE, style | WS_EX_APPWINDOW)

                # Load icons in different sizes
                ICON_BIG = 1
                ICON_SMALL = 0
                LR_LOADFROMFILE = 0x00000010

                # Load large icon (32x32)
                icon_big = ctypes.windll.user32.LoadImageW(
                    0, icon_path, 1, 32, 32, LR_LOADFROMFILE
                )

                # Load small icon (16x16)
                icon_small = ctypes.windll.user32.LoadImageW(
                    0, icon_path, 1, 16, 16, LR_LOADFROMFILE
                )

                # Set icons
                WM_SETICON = 0x0080
                if icon_big:
                    ctypes.windll.user32.SendMessageW(hwnd, WM_SETICON, ICON_BIG, icon_big)
                if icon_small:
                    ctypes.windll.user32.SendMessageW(hwnd, WM_SETICON, ICON_SMALL, icon_small)

                return True

        except Exception as e:
            print(f"IconManager error: {e}")

        return False

    @staticmethod
    def set_console_icon():
        """Set icon for console window"""
        try:
            if os.name == 'nt':
                kernel32 = ctypes.windll.kernel32
                console_handle = kernel32.GetConsoleWindow()
                if console_handle:
                    icon_path = 'app.ico'
                    if os.path.exists(icon_path):
                        ICON_BIG = 1
                        LR_LOADFROMFILE = 0x00000010

                        icon_handle = ctypes.windll.user32.LoadImageW(
                            0, icon_path, 1, 32, 32, LR_LOADFROMFILE
                        )

                        if icon_handle:
                            WM_SETICON = 0x0080
                            ctypes.windll.user32.SendMessageW(console_handle, WM_SETICON, ICON_BIG, icon_handle)
        except:
            pass


# legacy\src\utils\logger.py

# src/utils/logger.py

import logging
import logging.handlers
import threading
import sys
import os
from datetime import datetime
from typing import Callable, List


class CustomLogger:
    def __init__(self, log_file: str = None):
        self.subscribers: List[Callable[[str], None]] = []
        self._lock = threading.RLock()

        # Setup python logging
        self.logger = logging.getLogger("MidnightSpoofer")
        self.logger.setLevel(logging.DEBUG)

        # Formatter: [HH:MM:SS] [LEVEL] [CONTEXT] Message
        fmt = logging.Formatter("[%(asctime)s] [%(levelname)s] [%(context)s] %(message)s", datefmt="%H:%M:%S")

        # Console handler
        ch = logging.StreamHandler(sys.stdout)
        ch.setLevel(logging.DEBUG)
        ch.setFormatter(fmt)
        self.logger.addHandler(ch)

        # File handler (rotating) if requested
        if log_file is None:
            log_file = os.path.abspath(os.path.join(os.getcwd(), "midnight_log.txt"))
        fh = logging.handlers.RotatingFileHandler(log_file, maxBytes=5 * 1024 * 1024, backupCount=3, encoding='utf-8')
        fh.setLevel(logging.DEBUG)
        fh.setFormatter(fmt)
        self.logger.addHandler(fh)

    def add_subscriber(self, callback: Callable[[str], None]):
        """Register a GUI callback to receive formatted log strings."""
        with self._lock:
            if callback not in self.subscribers:
                self.subscribers.append(callback)

    def remove_subscriber(self, callback: Callable[[str], None]):
        with self._lock:
            if callback in self.subscribers:
                self.subscribers.remove(callback)

    def _notify_subscribers(self, record: logging.LogRecord):
        msg = self._format_record(record)
        with self._lock:
            for subscriber in list(self.subscribers):
                try:
                    subscriber(msg)
                except Exception:
                    # Subscribers must not break logging
                    pass

    def _format_record(self, record: logging.LogRecord) -> str:
        ctx = getattr(record, 'context', 'SYSTEM')
        timestamp = datetime.fromtimestamp(record.created).strftime("%H:%M:%S")
        return f"[{timestamp}] [{record.levelname}] [{ctx}] {record.getMessage()}"

    def _log(self, level: int, message: str, context: str = "SYSTEM"):
        extra = {'context': context}
        # Use the underlying logger to handle handlers
        self.logger.log(level, message, extra=extra)
        # Also notify subscribers with formatted message
        record = logging.LogRecord(name=self.logger.name, level=level, pathname=__file__, lineno=0, msg=message, args=(), exc_info=None)
        setattr(record, 'context', context)
        self._notify_subscribers(record)

    # Public convenience methods
    def debug(self, message: str, context: str = "SYSTEM"):
        self._log(logging.DEBUG, message, context)

    def info(self, message: str, context: str = "SYSTEM"):
        self._log(logging.INFO, message, context)

    def success(self, message: str, context: str = "SYSTEM"):
        # No native success level ‚Äî use INFO with SUCCESS context
        self._log(logging.INFO, message, context)

    def warning(self, message: str, context: str = "WARNING"):
        self._log(logging.WARNING, message, context)

    def error(self, message: str, context: str = "ERROR"):
        self._log(logging.ERROR, message, context)

    def exception(self, message: str, context: str = "ERROR"):
        # Log exception with stack trace
        self.logger.exception(message, extra={'context': context})
        # Notify subscribers as well
        record = logging.LogRecord(name=self.logger.name, level=logging.ERROR, pathname=__file__, lineno=0, msg=message, args=(), exc_info=None)
        setattr(record, 'context', context)
        self._notify_subscribers(record)

    # Backwards-compatible wrappers for previous API
    def log(self, message: str, level: str = "INFO", context: str = "SYSTEM"):
        """Compatibility wrapper: log(message, level, context)"""
        lvl = (level or "INFO").upper()
        if lvl == "DEBUG":
            self.debug(message, context)
        elif lvl in ("INFO",):
            self.info(message, context)
        elif lvl in ("SUCCESS",):
            self.success(message, context)
        elif lvl in ("WARNING", "WARN"):
            self.warning(message, context)
        elif lvl in ("ERROR",):
            self.error(message, context)
        elif lvl in ("CRITICAL",):
            self.error(message, context)
        else:
            self.info(message, context)

    def log_info(self, message: str, context: str = "SYSTEM"):
        self.info(message, context)

    def log_success(self, message: str, context: str = "SUCCESS"):
        self.success(message, context)

    def log_warning(self, message: str, context: str = "WARNING"):
        self.warning(message, context)

    def log_error(self, message: str, context: str = "ERROR"):
        self.error(message, context)

    def log_critical(self, message: str, context: str = "CRITICAL"):
        self.error(message, context)


# Global logger instance
logger = CustomLogger()

# legacy\src\utils\registry_checker.py

"""Centralized registry access helper for MidnightSpoofer.

Provides safe read/write/delete/enumeration helpers, dry-run mode,
backup/restore and transactional writes with rollback.
"""
# src/utils/registry_checker.py

from __future__ import annotations

import json
import os
import threading
import time
import hashlib
import getpass
from datetime import datetime
from typing import Any, Callable, Dict, List, Optional, Tuple

import winreg

from utils.logger import logger


class RegistryError(Exception):
    pass


class RegistryChecker:
    def __init__(self, backup_dir: Optional[str] = None):
        self.lock = threading.RLock()
        self.dry_run = False
        self.backup_dir = backup_dir or os.path.join(os.getcwd(), "registry_backups")
        os.makedirs(self.backup_dir, exist_ok=True)

    # ----------------------- Utilities -----------------------
    def _hive_from_string(self, hive: str):
        mapping = {
            "HKEY_LOCAL_MACHINE": winreg.HKEY_LOCAL_MACHINE,
            "HKLM": winreg.HKEY_LOCAL_MACHINE,
            "HKEY_CURRENT_USER": winreg.HKEY_CURRENT_USER,
            "HKCU": winreg.HKEY_CURRENT_USER,
            "HKEY_USERS": winreg.HKEY_USERS,
            "HKEY_CLASSES_ROOT": winreg.HKEY_CLASSES_ROOT,
        }
        try:
            return mapping[hive]
        except KeyError:
            raise RegistryError(f"Unknown hive: {hive}")

    def _backup_path(self, name: Optional[str] = None) -> str:
        ts = datetime.utcnow().strftime("%Y%m%dT%H%M%SZ")
        name = name or f"backup_{ts}.json"
        return os.path.join(self.backup_dir, name)

    def _hash_payload(self, payload: bytes) -> str:
        return hashlib.sha256(payload).hexdigest()

    # ----------------------- Modes -----------------------
    def set_dry_run(self, enabled: bool):
        self.dry_run = bool(enabled)
        logger.log_info(f"RegistryChecker dry-run set to {self.dry_run}", "RegistryChecker")

    def ensure_admin_or_raise(self):
        try:
            # Try to open a protected key for write to test permissions
            with winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, r"SOFTWARE", 0, winreg.KEY_WRITE):
                return True
        except Exception:
            raise RegistryError("Administrator privileges required to perform this operation")

    # ----------------------- Read / List -----------------------
    def read_value(self, hive: str, path: str, name: str) -> Tuple[Any, int]:
        hive_const = self._hive_from_string(hive)
        try:
            with winreg.OpenKey(hive_const, path, 0, winreg.KEY_READ) as key:
                value, vtype = winreg.QueryValueEx(key, name)
                logger.log_info(f"Read registry {hive}\\{path} :: {name} = {self._truncate_value(value)}", "RegistryChecker")
                return value, vtype
        except FileNotFoundError:
            raise RegistryError(f"Key or value not found: {hive}\\{path} -> {name}")
        except Exception as e:
            raise RegistryError(str(e))

    def list_values(self, hive: str, path: str) -> Dict[str, Tuple[Any, int]]:
        hive_const = self._hive_from_string(hive)
        results: Dict[str, Tuple[Any, int]] = {}
        try:
            with winreg.OpenKey(hive_const, path, 0, winreg.KEY_READ) as key:
                i = 0
                while True:
                    try:
                        name, value, vtype = winreg.EnumValue(key, i)
                        results[name] = (value, vtype)
                        i += 1
                    except OSError:
                        break
            logger.log_info(f"Listed {len(results)} values at {hive}\\{path}", "RegistryChecker")
            return results
        except FileNotFoundError:
            raise RegistryError(f"Key not found: {hive}\\{path}")
        except Exception as e:
            raise RegistryError(str(e))

    def enumerate_subkeys(self, hive: str, path: str) -> List[str]:
        hive_const = self._hive_from_string(hive)
        subs: List[str] = []
        try:
            with winreg.OpenKey(hive_const, path, 0, winreg.KEY_READ) as key:
                i = 0
                while True:
                    try:
                        sub = winreg.EnumKey(key, i)
                        subs.append(sub)
                        i += 1
                    except OSError:
                        break
            logger.log_info(f"Enumerated {len(subs)} subkeys at {hive}\\{path}", "RegistryChecker")
            return subs
        except FileNotFoundError:
            raise RegistryError(f"Key not found: {hive}\\{path}")
        except Exception as e:
            raise RegistryError(str(e))

    def find_subkey_by_value(self, hive: str, base_path: str, value_name: str, match_fn: Callable[[Any], bool]) -> Optional[str]:
        subs = self.enumerate_subkeys(hive, base_path)
        for sub in subs:
            try:
                val, _ = self.read_value(hive, os.path.join(base_path, sub), value_name)
                if match_fn(val):
                    return sub
            except RegistryError:
                continue
        return None

    # ----------------------- Write / Delete -----------------------
    def write_value(self, hive: str, path: str, name: str, value: Any, value_type: int = winreg.REG_SZ, backup: bool = True) -> bool:
        hive_const = self._hive_from_string(hive)
        full_path = f"{hive}\\{path}\\{name}"
        with self.lock:
            if self.dry_run:
                logger.log_info(f"[DRY-RUN] Write {full_path} = {self._truncate_value(value)}", "RegistryChecker")
                return True

            if backup:
                try:
                    self._save_backup_for_key(hive, path, [name])
                except Exception as e:
                    logger.log_warning(f"Failed to backup before write: {e}", "RegistryChecker")

            try:
                # ensure key exists (create if necessary)
                key = winreg.CreateKeyEx(hive_const, path, 0, winreg.KEY_WRITE)
                with key:
                    winreg.SetValueEx(key, name, 0, value_type, value)
                logger.log_info(f"Wrote registry {full_path}", "RegistryChecker")
                return True
            except Exception as e:
                raise RegistryError(str(e))

    def delete_value(self, hive: str, path: str, name: str, backup: bool = True) -> bool:
        hive_const = self._hive_from_string(hive)
        full_path = f"{hive}\\{path}\\{name}"
        with self.lock:
            if self.dry_run:
                logger.log_info(f"[DRY-RUN] Delete {full_path}", "RegistryChecker")
                return True

            if backup:
                try:
                    self._save_backup_for_key(hive, path, [name])
                except Exception as e:
                    logger.log_warning(f"Failed to backup before delete: {e}", "RegistryChecker")

            try:
                with winreg.OpenKey(hive_const, path, 0, winreg.KEY_SET_VALUE) as key:
                    winreg.DeleteValue(key, name)
                logger.log_info(f"Deleted registry value {full_path}", "RegistryChecker")
                return True
            except FileNotFoundError:
                raise RegistryError(f"Value not found: {full_path}")
            except Exception as e:
                raise RegistryError(str(e))

    # ----------------------- Transactional -----------------------
    def transactional_write(self, ops: List[Dict]) -> bool:
        """ops: list of {action: 'write'|'delete', hive, path, name, value?, value_type?}

        Rolls back all changes if any operation fails.
        """
        with self.lock:
            # Build backup for all affected keys
            backup_items: List[Tuple[str, str, List[str]]] = []  # (hive, path, [names])
            for op in ops:
                backup_items.append((op["hive"], op["path"], [op["name"]]))

            backup_file = self._save_backup_for_items(backup_items)

            # Apply operations
            try:
                for op in ops:
                    action = op.get("action")
                    if action == "write":
                        self.write_value(op["hive"], op["path"], op["name"], op.get("value"), op.get("value_type", winreg.REG_SZ), backup=False)
                    elif action == "delete":
                        self.delete_value(op["hive"], op["path"], op["name"], backup=False)
                    else:
                        raise RegistryError(f"Unknown op action: {action}")
                logger.log_info(f"Transactional write succeeded; backup: {backup_file}", "RegistryChecker")
                return True
            except Exception as e:
                logger.log_error(f"Transactional write failed: {e}; rolling back", "RegistryChecker")
                try:
                    self.restore(backup_file)
                except Exception as re:
                    logger.log_error(f"Rollback failed: {re}", "RegistryChecker")
                raise

    # ----------------------- Backup / Restore -----------------------
    def _save_backup_for_items(self, items: List[Tuple[str, str, List[str]]]) -> str:
        # items: list of (hive, path, [names])
        payload = {"meta": {"created_by": getpass.getuser(), "ts": time.time()}, "data": {}}
        for hive, path, names in items:
            try:
                values = self.list_values(hive, path)
            except RegistryError:
                values = {}
            # filter only requested names
            filtered = {k: v for k, v in values.items() if k in names}
            payload["data"][f"{hive}\\{path}"] = filtered

        raw = json.dumps(payload, default=str).encode("utf-8")
        fname = self._backup_path()
        with open(fname, "wb") as f:
            f.write(raw)

        sig = self._hash_payload(raw)
        metafname = fname + ".sig"
        with open(metafname, "w") as f:
            f.write(sig)

        logger.log_info(f"Saved registry backup: {fname}", "RegistryChecker")
        return fname

    def _save_backup_for_key(self, hive: str, path: str, names: List[str]) -> str:
        return self._save_backup_for_items([(hive, path, names)])

    def restore(self, backup_file: str) -> bool:
        if not os.path.exists(backup_file):
            raise RegistryError("Backup file not found")
        with open(backup_file, "rb") as f:
            raw = f.read()
        # Optional: verify signature
        sigfile = backup_file + ".sig"
        if os.path.exists(sigfile):
            with open(sigfile, "r") as f:
                sig = f.read().strip()
            if sig != self._hash_payload(raw):
                logger.log_warning("Backup signature mismatch", "RegistryChecker")

        payload = json.loads(raw.decode("utf-8"))
        data = payload.get("data", {})

        # Apply values
        for keypath, values in data.items():
            try:
                hive_str, reg_path = keypath.split("\\", 1)
            except ValueError:
                continue
            for name, (value, vtype) in values.items():
                try:
                    self.write_value(hive_str, reg_path, name, value, value_type=vtype, backup=False)
                except Exception as e:
                    logger.log_error(f"Failed to restore {keypath}::{name} -> {e}", "RegistryChecker")
        logger.log_info(f"Restored registry from {backup_file}", "RegistryChecker")
        return True

    # ----------------------- Helpers -----------------------
    def _truncate_value(self, value: Any, max_length: int = 50) -> str:
        try:
            s = str(value)
            if len(s) > max_length:
                return s[:max_length] + "..."
            return s
        except Exception:
            return "<unserializable>"

    # Backwards compat / reporting helpers
    def get_spoofing_readiness_report(self) -> Dict[str, Any]:
        report = {"ok": True, "checked_at": datetime.utcnow().isoformat()}
        return report

# Lunar\config.json

{}

# Lunar\main.py

"""
PONTO DE ENTRADA PRINCIPAL - Lunar Spoofer
"""
import sys
import os
import ctypes
import traceback

def check_admin_privileges():
    """Verifica se est√° executando como administrador"""
    try:
        return ctypes.windll.shell32.IsUserAnAdmin()
    except:
        return False

def setup_environment():
    """Configura o ambiente Python"""
    # Adicionar src ao path
    src_path = os.path.join(os.path.dirname(__file__), 'src')
    if src_path not in sys.path:
        sys.path.insert(0, src_path)

def main():
    """Fun√ß√£o principal"""
    print("Inicializando Lunar Spoofer...")

    # Configurar ambiente
    setup_environment()

    # Verificar privil√©gios
    if not check_admin_privileges():
        print("ERRO: Execute como Administrador!")
        input("Pressione Enter para sair...")
        return 1

    try:
        from src.core.app import LunarApp

        # Criar e executar aplica√ß√£o
        app = LunarApp()
        return app.run()

    except Exception as e:
        print(f"Erro fatal na inicializa√ß√£o: {e}")
        print(f"Traceback: {traceback.format_exc()}")
        input("Pressione Enter para sair...")
        return 1

if __name__ == "__main__":
    exit_code = main()
    sys.exit(exit_code)


# Lunar\README.md

# Documentation

TODO


# Lunar\run_pyside.py

# TODO: Implement


# Lunar\script.py

import os
import pathlib

def export_project_structure(root_dir, output_file):
    # Lista de extens√µes de arquivos de c√≥digo (personaliz√°vel)
    code_extensions = {
        '.py', '.js', '.html', '.css', '.java', '.c', '.cpp', '.cs', '.php', '.rb',
        '.go', '.rs', '.ts', '.sql', '.json', '.xml', '.yaml', '.yml', '.md', '.cfg',
        '.conf', '.ini', '.sh', '.bat', '.ps1', '.vue', '.jsx',
        '.tsx', '.scss', '.sass', '.less', '.asm', '.swift', '.kt', '.dart'
    }
    
    with open(output_file, 'w', encoding='utf-8') as outfile:
        for root, dirs, files in os.walk(root_dir):
            # Ignorar pastas de vers√£o (personaliz√°vel)
            ignore_dirs = {'.git', '__pycache__', 'node_modules', 'vendor', 'dist', 'build'}
            dirs[:] = [d for d in dirs if d not in ignore_dirs]
            
            for file in files:
                file_path = pathlib.Path(root) / file
                relative_path = file_path.relative_to(root_dir)
                
                # Verificar se √© um arquivo de c√≥digo
                if file_path.suffix.lower() in code_extensions:
                    try:
                        with open(file_path, 'r', encoding='utf-8') as infile:
                            content = infile.read()
                    except UnicodeDecodeError:
                        try:
                            with open(file_path, 'r', encoding='latin-1') as infile:
                                content = infile.read()
                        except Exception:
                            content = f"[ERRO: N√£o foi poss√≠vel ler o arquivo {relative_path}]\n"
                    except Exception as e:
                        content = f"[ERRO: {str(e)}]\n"

                    # Escrever no arquivo de sa√≠da
                    outfile.write(f"# {relative_path}\n\n")
                    outfile.write(content)
                    outfile.write("\n\n")

if __name__ == "__main__":
    project_root = input("Digite o caminho completo do projeto (ou Enter para usar o diret√≥rio atual): ").strip()
    if not project_root:
        project_root = os.getcwd()
    
    output_filename = "projeto_completo.txt"
    export_project_structure(project_root, output_filename)
    print(f"Arquivo '{output_filename}' gerado com sucesso!")

# Lunar\docs\migration_guide.md

# Documentation

TODO


# Lunar\docs\ui_specs.md

# Documentation

TODO


# Lunar\src\auth\auth_system_firebase.py

# TODO: Implement


# Lunar\src\auth\license_generator.py

# TODO: Implement


# Lunar\src\auth\login_handler.py

# TODO: Implement


# Lunar\src\cleaners\system_cleaner.py

class SystemCleaner:
    def __init__(self):
        pass


# Lunar\src\cleaners\system_paths.py

# TODO: Implement


# Lunar\src\controllers\spoofer_controller.py

class SpoofingController:
    def __init__(self, cleaner, mac_spoofer, hwid_spoofer, guid_spoofer, hw_reader):
        self.cleaner = cleaner
        self.mac_spoofer = mac_spoofer
        self.hwid_spoofer = hwid_spoofer
        self.guid_spoofer = guid_spoofer
        self.hw_reader = hw_reader


# Lunar\src\core\app.py

import sys
import os
from PySide6.QtWidgets import QApplication, QMessageBox
from PySide6.QtCore import QTimer
from PySide6.QtGui import QIcon

class LunarApp:
    def __init__(self):
        # Criar QApplication PRIMEIRO
        self.qt_app = QApplication(sys.argv)
        self.main_window = None

        # Configura√ß√£o b√°sica
        self.setup_application()

    def setup_application(self):
        """Configura√ß√µes iniciais seguras"""
        self.qt_app.setApplicationName("Lunar Spoofer")
        self.qt_app.setApplicationVersion("1.0.0")

        # Tentar carregar √≠cone, mas n√£o cr√≠tico
        try:
            icon_path = "assets/icons/app.ico"
            if os.path.exists(icon_path):
                self.qt_app.setWindowIcon(QIcon(icon_path))
        except:
            pass  # √çcone n√£o √© cr√≠tico

    def initialize_components(self):
        """Inicializa√ß√£o segura dos componentes"""
        try:
            # Importar aqui para evitar depend√™ncias circulares
            from src.ui.main_window import MainWindow

            # Inicializar controladores b√°sicos (simplificado por enquanto)
            spoofer_controller = self.create_dummy_controller()

            # Criar janela principal
            self.main_window = MainWindow(spoofer_controller)
            return True

        except Exception as e:
            print(f"Erro cr√≠tico na inicializa√ß√£o: {e}")
            self.show_error_message(str(e))
            return False

    def create_dummy_controller(self):
        """Cria controlador tempor√°rio para testes"""
        class DummyController:
            def __init__(self):
                self.status = "Ready"

        return DummyController()

    def show_error_message(self, error_details):
        """Mostra mensagem de erro amig√°vel"""
        msg = QMessageBox()
        msg.setIcon(QMessageBox.Critical)
        msg.setWindowTitle("Erro de Inicializa√ß√£o")
        msg.setText("N√£o foi poss√≠vel iniciar o Lunar Spoofer")
        msg.setInformativeText(f"Detalhes: {error_details}")
        msg.setDetailedText(f"Traceback completo:\n{error_details}")
        msg.exec()

    def run(self):
        """Executa a aplica√ß√£o de forma segura"""
        print("Iniciando Lunar Spoofer...")

        try:
            if self.initialize_components():
                self.main_window.show()
                print("Aplica√ß√£o iniciada com sucesso")
                return self.qt_app.exec()
            else:
                print("Falha na inicializa√ß√£o")
                return 1

        except Exception as e:
            print(f"Erro fatal: {e}")
            self.show_error_message(str(e))
            return 1


# Lunar\src\core\config.py

import json
import os
from pathlib import Path

class Config:
    def __init__(self):
        self.config_path = Path("config.json")
        self.default_config = {
            "theme": "purple",
            "window_size": [1400, 900],
            "auto_start": False,
            "admin_required": True,
            "log_level": "INFO"
        }
        self.config = self.load_config()

    def load_config(self):
        """Carrega configura√ß√£o do arquivo ou cria padr√£o"""
        if self.config_path.exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    return {**self.default_config, **json.load(f)}
            except Exception as e:
                print(f"Erro ao carregar config: {e}")
                return self.default_config
        else:
            self.save_config(self.default_config)
            return self.default_config

    def save_config(self, config=None):
        """Salva configura√ß√£o no arquivo"""
        if config is None:
            config = self.config

        try:
            with open(self.config_path, 'w', encoding='utf-8') as f:
                json.dump(config, f, indent=4, ensure_ascii=False)
            return True
        except Exception as e:
            print(f"Erro ao salvar config: {e}")
            return False

    def get(self, key, default=None):
        """Obt√©m valor da configura√ß√£o"""
        return self.config.get(key, default)

    def set(self, key, value):
        """Define valor da configura√ß√£o"""
        self.config[key] = value
        return self.save_config()


# Lunar\src\spoofers\guid_spoofer\guid_paths.py

# TODO: Implement


# Lunar\src\spoofers\guid_spoofer\guid_spoofer.py

# TODO: Implement


# Lunar\src\spoofers\hwid_spoofer\hwid_paths.py

# TODO: Implement


# Lunar\src\spoofers\hwid_spoofer\hwid_spoofer.py

# TODO: Implement


# Lunar\src\spoofers\mac_spoofer\mac_paths.py

# TODO: Implement


# Lunar\src\spoofers\mac_spoofer\mac_spoofer.py

# TODO: Implement


# Lunar\src\spoofers\mac_spoofer\network_utils.py

# TODO: Implement


# Lunar\src\ui\login_window.py

# TODO: Implement


# Lunar\src\ui\main_window.py

from PySide6.QtWidgets import (QMainWindow, QWidget, QVBoxLayout,
                              QHBoxLayout, QStatusBar, QMessageBox, QLabel, QFrame,
                              QPushButton)
from PySide6.QtCore import Qt, QTimer
from PySide6.QtGui import QFont, QPalette, QColor, QIcon, QPixmap
import os

from src.ui.components.sidebar import Sidebar
from src.ui.components.dashboard import Dashboard
from src.ui.components.particles import ParticleSystem
import traceback

class MainWindow(QMainWindow):
    def __init__(self, spoofer_controller):
        super().__init__()
        self.controller = spoofer_controller
        self.current_page = "dashboard"

        self.setup_window()
        QTimer.singleShot(100, self.initialize_ui)

    def setup_window(self):
        """Configura√ß√£o da janela principal"""
        self.setWindowTitle("Lunar Spoofer - Advanced System Protection")
        self.setGeometry(100, 100, 1400, 900)
        self.setMinimumSize(1200, 800)

        # Aplicar fundo b√°sico
        self.setStyleSheet("QMainWindow { background-color: #1a1a1a; }")
        
        self.center_on_screen()

    def center_on_screen(self):
        """Centraliza a janela"""
        screen = self.screen().availableGeometry()
        window_size = self.frameGeometry()
        self.move(
            (screen.width() - window_size.width()) // 2,
            (screen.height() - window_size.height()) // 2
        )

    def initialize_ui(self):
        """Inicializa a UI com part√≠culas"""
        try:
            self.setup_ui()
            self.load_stylesheet()
            print("Interface Lunar com part√≠culas carregada")

            # Inicializar part√≠culas ap√≥s um pequeno delay
            QTimer.singleShot(100, self.initialize_particles)

        except Exception as e:
            print(f"Erro na UI: {e}")
            self.setup_fallback_ui()

    def setup_ui(self):
        """Configura a interface completa"""
        # Widget central
        central_widget = QWidget()
        central_widget.setObjectName("centralWidget")
        self.setCentralWidget(central_widget)

        # Layout principal (REMOVIDO PARA PERMITIR SOBREPOSI√á√ÉO)
        # main_layout = QVBoxLayout(central_widget)
        # main_layout.setContentsMargins(0, 0, 0, 0)
        # main_layout.setSpacing(0)

        # Sistema de part√≠culas como overlay transparente - FUNDO
        self.particle_system = ParticleSystem(central_widget)

        # HeaderBar REMOVED

        # √Årea de conte√∫do principal
        self.content_stack = QFrame(central_widget)
        self.content_stack.setObjectName("contentStack")
        content_stack_layout = QVBoxLayout(self.content_stack)
        content_stack_layout.setContentsMargins(0, 0, 0, 0)
        content_stack_layout.setSpacing(0)

        # Dashboard
        self.dashboard = Dashboard(self.controller)
        content_stack_layout.addWidget(self.dashboard)

        # Sidebar (CAMADA SUPERIOR)
        self.sidebar = Sidebar(central_widget)

        # Floating buttons (header buttons moved here)
        self.message_btn = self.create_icon_button("message.png", "Messages")
        self.message_btn.setParent(central_widget)

        self.notification_btn = self.create_icon_button("no_notification.png", "Notifications")
        self.notification_btn.setParent(central_widget)

        self.user_widget = self.create_user_widget()
        self.user_widget.setParent(central_widget)

        # Barra de status
        self.setup_status_bar()

        # Conectar navega√ß√£o
        self.sidebar.navigation_changed.connect(self.on_navigation_changed)

        # Chamar a l√≥gica de posicionamento pela primeira vez
        self.update_geometries()

    def on_navigation_changed(self, page_id):
        """Handler de navega√ß√£o"""
        self.current_page = page_id

        status_messages = {
            "dashboard": "Dashboard - System overview and security controls",
            "tools": "Tools - Advanced system utilities",
            "system_info": "System Info - Hardware and software information",
            "settings": "Settings - Application configuration"
        }

        self.statusBar().showMessage(status_messages.get(page_id, "System ready"))
        print(f"Navegando para: {page_id}")

    def setup_fallback_ui(self):
        """UI de fallback"""
        central_widget = QWidget()
        self.setCentralWidget(central_widget)

        layout = QVBoxLayout(central_widget)
        error_label = QLabel("System interface compatibility mode")
        error_label.setAlignment(Qt.AlignCenter)
        error_label.setStyleSheet("color: white;")
        layout.addWidget(error_label)

    def setup_status_bar(self):
        """Configura barra de status"""
        status_bar = QStatusBar()
        status_bar.showMessage("Lunar Spoofer initialized - Modern theme active")
        self.setStatusBar(status_bar)

    def resizeEvent(self, event):
        """Gerencia a geometria dos componentes para sobreposi√ß√£o"""
        super().resizeEvent(event)
        self.update_geometries()

    def update_geometries(self):
        """Posiciona os widgets manualmente para permitir sobreposi√ß√£o"""
        w = self.width()
        h = self.height()

        # 1. Part√≠culas (fundo)
        if hasattr(self, 'particle_system'):
            self.particle_system.setGeometry(0, 0, w, h)
            self.particle_system.lower()

        # 2. Content Stack (starts at top now, behind sidebar)
        if hasattr(self, 'content_stack'):
            if hasattr(self, 'sidebar'):
                sidebar_width = self.sidebar.width()
                self.content_stack.setGeometry(
                    sidebar_width,
                    0,  # Starts at Y=0
                    w - sidebar_width,
                    h  # Occupies full height
                )
            else:
                self.content_stack.setGeometry(0, 0, w, h)

        # 4. Sidebar (topo)
        if hasattr(self, 'sidebar'):
            sidebar_width = self.sidebar.width() # Pega a largura fixa (150)
            # A sidebar come√ßa em (0, 0) e ocupa a altura total
            self.sidebar.setGeometry(0, 0, sidebar_width, h)
            self.sidebar.raise_() # Coloca a sidebar no topo

        # 5. Floating buttons (positioned in top-right corner)
        margin = 30
        spacing = 15
        button_size = 40 # AUMENTADO DE 32 para 40

        if hasattr(self, 'user_widget'):
            user_width = self.user_widget.width()
            user_height = self.user_widget.height()

            # Centralizar verticalmente os bot√µes em rela√ß√£o ao user_widget
            button_y = margin + (user_height / 2) - (button_size / 2)

            # Posicionar User Widget
            self.user_widget.setGeometry(w - user_width - margin, margin, user_width, user_height)
            self.user_widget.raise_()

            if hasattr(self, 'notification_btn'):
                # Usar button_size e button_y
                self.notification_btn.setGeometry(
                    w - user_width - margin - button_size - spacing,
                    button_y,
                    button_size,
                    button_size
                )
                self.notification_btn.raise_()

                if hasattr(self, 'message_btn'):
                    # Usar button_size e button_y
                    self.message_btn.setGeometry(
                        w - user_width - margin - button_size - spacing - button_size - spacing,
                        button_y,
                        button_size,
                        button_size
                    )
                    self.message_btn.raise_()

    # Methods moved from header_bar.py

    def create_icon_button(self, icon_filename, tooltip):
        btn = QPushButton()
        btn.setObjectName("iconButton")  # CSS will still work
        btn.setFixedSize(40, 40) # AUMENTADO DE 32, 32
        btn.setCursor(Qt.PointingHandCursor)
        btn.setToolTip(tooltip)

        icon_path = os.path.join(os.path.dirname(__file__), '..', '..', 'assets', 'icons', icon_filename)

        if not os.path.exists(icon_path):
           icon_path = os.path.join(os.path.dirname(__file__), '..', 'icons', icon_filename)

        if os.path.exists(icon_path):
            pixmap = QPixmap(icon_path)
            # AUMENTADO DE 24, 24 para 30, 30
            pixmap = pixmap.scaled(30, 30, Qt.KeepAspectRatio, Qt.SmoothTransformation)
            btn.setIcon(QIcon(pixmap))
            btn.setIconSize(pixmap.size())
        else:
            print(f"√çcone n√£o encontrado: {icon_path}")
            btn.setText("üìß" if "message" in icon_filename else "üîî")
        return btn

    def create_user_widget(self):
        widget = QFrame()
        widget.setObjectName("userWidget")  # CSS will still work
        layout = QVBoxLayout(widget)
        # AUMENTADO MARGENS de (8, 4, 8, 4) para (10, 6, 10, 6)
        layout.setContentsMargins(10, 6, 10, 6)
        layout.setSpacing(2)

        user_label = QLabel("User")
        user_label.setObjectName("userLabel")
        # AUMENTADO FONTE de 12 para 15
        user_label.setFont(QFont("Segoe UI", 15, QFont.Bold))

        role_label = QLabel("Administrator")
        role_label.setObjectName("roleLabel")
        # AUMENTADO FONTE de 9 para 11
        role_label.setFont(QFont("Segoe UI", 11))

        layout.addWidget(user_label)
        layout.addWidget(role_label)
        widget.setFixedSize(widget.sizeHint())  # Define fixed size
        return widget

    def initialize_particles(self):
        """Inicializa e posiciona o sistema de part√≠culas"""
        if hasattr(self, 'particle_system'):
            self.particle_system.setGeometry(0, 0, self.width(), self.height())
            self.particle_system.update()

    def load_stylesheet(self):
        """Carrega CSS atualizado de forma mais robusta"""
        try:
            # Constr√≥i um caminho absoluto para o arquivo CSS
            current_dir = os.path.dirname(os.path.abspath(__file__))
            css_path = os.path.join(current_dir, 'styles', 'main.css')

            if os.path.exists(css_path):
                with open(css_path, 'r', encoding='utf-8') as f:
                    css_content = f.read()
                    # Aplicar CSS
                    self.setStyleSheet(css_content)
                print(f"CSS aplicado com sucesso de: {css_path}")
            else:
                print(f"ERRO: Arquivo CSS n√£o encontrado em: {css_path}")
                self.apply_minimal_styles()
        except Exception as e:
            print(f"Erro ao carregar CSS: {e}")
            self.apply_minimal_styles()

    def apply_minimal_styles(self):
        """Aplica estilos m√≠nimos para garantir funcionamento"""
        minimal_css = """
            QMainWindow {
                background-color: #1a1a1a;
                color: #ffffff;
            }

            /* ===== ESTILOS DO HEADER ADICIONADOS AQUI ===== */
            #headerBar {
                background: qlineargradient(x1:0, y1:0, x2:1, y2:0, stop:0 #2d2d2d, stop:1 #3a3a3a);
                border-bottom: 2px solid #4a4a4a;
                outline: none;
            }
            #headerTitle {
                color: #ffffff;
                background: transparent;
                font-size: 16px;
                font-weight: bold;
            }
            #headerSubtitle {
                color: #cccccc;
                background: transparent;
                font-size: 10px;
            }
            #userLabel {
                color: #ffffff;
                background: transparent;
            }
            #roleLabel {
                color: #cccccc;
                background: transparent;
            }
            /* ============================================== */

            QPushButton#mainSpoofButton {
                background: qlineargradient(x1:0, y1:0, x2:1, y2:0, stop:0 #4a90e2, stop:1 #50e3c2);
                color: #000000;
                border: none;
                border-radius: 8px;
                font-size: 13px;
                font-weight: bold;
                padding: 14px 28px;
            }
            QPushButton#mainSpoofButton:hover {
                background: qlineargradient(x1:0, y1:0, x2:1, y2:0, stop:0 #5a9fee, stop:1 #60f3d2);
            }
            QLabel#hardwareValue {
                font-size: 16px;
                font-weight: bold;
            }
        """
        self.setStyleSheet(minimal_css)

    def closeEvent(self, event):
        """Handler de fechamento"""
        reply = QMessageBox.question(
            self, 'Exit Confirmation',
            'Are you sure you want to exit Lunar Spoofer?',
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
            QMessageBox.StandardButton.No
        )

        if reply == QMessageBox.StandardButton.Yes:
            event.accept()
        else:
            event.ignore()


# Lunar\src\ui\adapters\controller_adapter.py

# TODO: Implement


# Lunar\src\ui\adapters\theme_manager.py

# TODO: Implement


# Lunar\src\ui\components\dashboard.py

from PySide6.QtWidgets import (QFrame, QVBoxLayout, QHBoxLayout, QLabel,
                              QPushButton, QGridLayout, QWidget)
from PySide6.QtCore import Qt, QTimer
from PySide6.QtGui import QFont
# import psutil # REMOVED (now in hardware_reader)

# NEW IMPORTS
from src.utils.hardware_reader import HardwareReader
from src.ui.components.hardware_graphs import MiniGraphWidget

from src.ui.components.switch import SwitchButton

# NEW: Define a ceiling for the DISK graph (ex: 100 MB/s = 100%)
DISK_GRAPH_MAX_MB_S = 100.0

class Dashboard(QFrame):
    def __init__(self, controller=None):
        super().__init__()
        self.controller = controller
        self.switch_states = {
            "mac": False,
            "guid": False,
            "hwid": False
        }

        # Instantiate the reader
        self.hw_reader = HardwareReader()

        self.setup_ui()
        self.setup_timers()

    def setup_ui(self):
        """Configura dashboard com hardware stats ACIMA e flutuante"""
        self.setObjectName("dashboard")

        # Layout principal REMOVIDO
        # main_layout = QVBoxLayout(self)
        # main_layout.setContentsMargins(30, 20, 30, 20)
        # main_layout.setSpacing(25)
        self.setLayout(None) # Define layout nulo para posicionamento manual

        # Painel de hardware (agora flutuante)
        self.hardware_panel = self.create_hardware_panel()
        self.hardware_panel.setParent(self) # Define o parent
        # main_layout.addWidget(hardware_panel) # REMOVIDO

        # √Årea de conte√∫do principal
        self.content_area = self.create_content_area()
        self.content_area.setParent(self) # Define o parent
        # main_layout.addWidget(content_area) # REMOVIDO

    def resizeEvent(self, event):
        """Posiciona os pain√©is manualmente"""
        super().resizeEvent(event)
        w = self.width()
        h = self.height()

        panel_height = 60
        # ALTERADO DE 20 PARA 30 (para alinhar com os √≠cones do header)
        panel_margin_top = 30
        # ALTERADO DE 110 PARA 120 (para descer o conte√∫do)
        content_margin_top = 120

        # Posiciona o painel de hardware no topo e centro
        if hasattr(self, 'hardware_panel'):
            panel_width = self.hardware_panel.width() # 600px fixo
            self.hardware_panel.setGeometry(
                30,  # Alinhado √† esquerda com o conte√∫do
                panel_margin_top,        # Margem do topo
                panel_width,
                panel_height
            )
            self.hardware_panel.raise_()

        # Posiciona a √°rea de conte√∫do abaixo do painel
        if hasattr(self, 'content_area'):
            self.content_area.setGeometry(
                30, # Margem esquerda
                content_margin_top,
                w - 60, # Margem esquerda/direita
                h - content_margin_top - 20 # Margem topo/baixo
            )

    def create_content_area(self):
        """Cria √°rea de conte√∫do principal"""
        content_frame = QFrame()
        content_frame.setObjectName("contentFrame")

        layout = QHBoxLayout(content_frame)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(25)

        # Painel de a√ß√µes principal (esquerda)
        action_panel = self.create_action_panel()
        layout.addWidget(action_panel, 0, Qt.AlignTop)

        # Painel de m√≥dulos compacto (direita)
        modules_panel = self.create_compact_modules_panel()
        layout.addWidget(modules_panel, 0, Qt.AlignTop)

        return content_frame

    def create_hardware_panel(self):
        """Cria painel de informa√ß√µes de hardware (Estilo Pill)"""
        hardware_frame = QFrame()
        # [ALTERADO] Novo objectName para o CSS
        hardware_frame.setObjectName("pillHardwarePanel")
        hardware_frame.setFixedHeight(60) # de 80 para 60
        hardware_frame.setFixedWidth(900) # de 600 para 900

        layout = QHBoxLayout(hardware_frame)
        layout.setContentsMargins(20, 7, 20, 3) # Margens (esquerda/direita 20)
        layout.setSpacing(10) # Espa√ßamento reduzido

        # Stats de hardware (com gr√°ficos)
        self.cpu_stat = self.create_hardware_stat("CPU", "0%", "#50E3C2", show_graph=True)
        self.memory_stat = self.create_hardware_stat("MEMORY", "0%", "#4A90E2", show_graph=True)
        self.disk_stat = self.create_hardware_stat("DISK", "0 MB/s", "#B8E986", show_graph=True)
        self.status_stat = self.create_hardware_stat("STATUS", "READY", "#FF6B6B", show_graph=False)

        layout.addWidget(self.cpu_stat)
        layout.addStretch(1) # Espa√ßador
        layout.addWidget(self.memory_stat)
        layout.addStretch(1) # Espa√ßador
        layout.addWidget(self.disk_stat)
        layout.addStretch(1) # Espa√ßador
        layout.addWidget(self.status_stat)

        return hardware_frame

    def create_hardware_stat(self, title, value, color, show_graph=True):
        """Cria widget de stat (Texto + Gr√°fico Opcional)"""

        # Widget principal (Stat + Gr√°fico)
        main_widget = QFrame()
        main_layout = QHBoxLayout(main_widget)
        main_layout.setContentsMargins(0, 0, 0, 0)
        main_layout.setSpacing(10)

        # Widget de Texto (T√≠tulo + Valor)
        text_widget = QFrame()
        text_layout = QVBoxLayout(text_widget)
        text_layout.setContentsMargins(0, 0, 0, 0)
        text_layout.setSpacing(4)
        text_layout.setAlignment(Qt.AlignCenter)
        text_widget.setFixedWidth(80) # Largura fixa para o texto

        title_label = QLabel(title)
        title_label.setObjectName("hardwareTitle")
        title_label.setFont(QFont("Segoe UI", 10, QFont.Medium))
        title_label.setAlignment(Qt.AlignLeft | Qt.AlignVCenter)

        value_label = QLabel(value)
        value_label.setObjectName("hardwareValue")
        value_label.setFont(QFont("Segoe UI", 16, QFont.Bold))
        value_label.setAlignment(Qt.AlignLeft | Qt.AlignVCenter)
        value_label.setStyleSheet(f"color: {color}; background: transparent;")

        text_layout.addWidget(title_label)
        text_layout.addWidget(value_label)

        main_layout.addWidget(text_widget) # Adiciona texto √† esquerda

        # Gr√°fico (Direita)
        if show_graph:
            graph_widget = MiniGraphWidget()
            graph_widget.set_color(color)
            main_layout.addWidget(graph_widget) # Adiciona gr√°fico √† direita

            # Armazenar refer√™ncia ao gr√°fico
            if title == "CPU":
                self.cpu_graph = graph_widget
            elif title == "MEMORY":
                self.memory_graph = graph_widget
            elif title == "DISK":
                self.disk_graph = graph_widget

            # (80px texto + 10px espa√ßo + 100px gr√°fico)
            main_widget.setFixedSize(190, 50)
        else:
            # Se n√£o houver gr√°fico, o tamanho √© menor
            main_widget.setFixedSize(90, 50)

        return main_widget

    def create_action_panel(self):
        """Cria painel de a√ß√µes principal"""
        action_frame = QFrame()
        action_frame.setObjectName("actionPanel")

        layout = QVBoxLayout(action_frame)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(20)

        # Container do bot√£o principal
        button_container = QFrame()
        button_container.setObjectName("buttonContainer")
        button_container.setFixedHeight(180)

        button_layout = QVBoxLayout(button_container)
        button_layout.setAlignment(Qt.AlignCenter)
        button_layout.setSpacing(15)

        # T√≠tulo
        title_label = QLabel("SYSTEM SECURITY")
        title_label.setObjectName("sectionTitle")
        title_label.setAlignment(Qt.AlignCenter)
        title_label.setFont(QFont("Segoe UI", 16, QFont.Bold))

        # Bot√£o de spoofing principal
        self.spoof_button = QPushButton("START SPOOFING")
        self.spoof_button.setObjectName("mainSpoofButton")
        self.spoof_button.setCursor(Qt.PointingHandCursor)
        self.spoof_button.setFixedHeight(52)
        self.spoof_button.clicked.connect(self.on_spoof_button_click)

        # Status do spoofing
        self.spoof_status = QLabel("System ready for spoofing protocol")
        self.spoof_status.setObjectName("spoofStatus")
        self.spoof_status.setAlignment(Qt.AlignCenter)
        self.spoof_status.setWordWrap(True)

        button_layout.addWidget(title_label)
        button_layout.addWidget(self.spoof_button)
        button_layout.addWidget(self.spoof_status)

        layout.addWidget(button_container)
        layout.addStretch(1)

        return action_frame

    def create_compact_modules_panel(self):
        """Cria painel de m√≥dulos compacto com switches"""
        modules_frame = QFrame()
        modules_frame.setObjectName("modulesPanel")
        modules_frame.setFixedWidth(300)

        layout = QVBoxLayout(modules_frame)
        layout.setContentsMargins(20, 20, 20, 20)
        layout.setSpacing(15)

        # T√≠tulo
        title = QLabel("SECURITY MODULES")
        title.setObjectName("modulesTitle")
        title.setFont(QFont("Segoe UI", 14, QFont.Bold))

        layout.addWidget(title)

        # Container dos switches
        switches_container = QWidget()
        switches_layout = QVBoxLayout(switches_container)
        switches_layout.setContentsMargins(0, 0, 0, 0)
        switches_layout.setSpacing(10)

        # M√≥dulos com switches
        modules_data = [
            ("MAC Address Spoofing", "mac"),
            ("GUID Spoofing", "guid"),
            ("HWID Spoofing", "hwid")
        ]

        self.module_switches = {}

        for module_name, module_id in modules_data:
            switch_widget = self.create_switch_row(module_name, module_id)
            switches_layout.addWidget(switch_widget)
            self.module_switches[module_id] = switch_widget.findChild(SwitchButton)

        layout.addWidget(switches_container)
        # layout.addStretch(1) # REMOVED - prevents vertical stretching

        return modules_frame

    def create_switch_row(self, name, module_id):
        """Cria uma linha compacta com switch"""
        row_widget = QFrame()
        row_widget.setObjectName(f"switchRow_{module_id}")
        row_widget.setFixedHeight(35)

        layout = QHBoxLayout(row_widget)
        layout.setContentsMargins(10, 0, 10, 0)
        layout.setSpacing(15)

        # Nome do m√≥dulo
        name_label = QLabel(name)
        name_label.setObjectName("moduleName")
        name_label.setFont(QFont("Segoe UI", 11))

        # Switch
        switch = SwitchButton()
        switch.setObjectName(f"moduleSwitch_{module_id}")
        switch.toggled.connect(lambda checked, mid=module_id: self.on_module_toggled(mid, checked))

        layout.addWidget(name_label)
        layout.addStretch(1)
        layout.addWidget(switch)

        return row_widget

    def on_module_toggled(self, module_id, checked):
        """Handler para toggle dos m√≥dulos"""
        self.switch_states[module_id] = checked
        status = "ENABLED" if checked else "DISABLED"
        print(f"Module {module_id}: {status}")

    def setup_timers(self):
        """Configura timers para atualiza√ß√£o em tempo real"""
        self.stats_timer = QTimer()
        self.stats_timer.timeout.connect(self.update_hardware_stats)
        # Atualiza√ß√£o mais r√°pida para o gr√°fico
        self.stats_timer.start(1000) # 1 segundo
        # A primeira chamada deve ser do timer, ap√≥s 1s.
        # self.update_hardware_stats()

    def on_spoof_button_click(self):
        """Handler do bot√£o de spoofing"""
        # Coletar estados dos switches
        enabled_modules = [mid for mid, state in self.switch_states.items() if state]

        if not enabled_modules:
            self.spoof_status.setText("No modules enabled for spoofing")
            return

        self.spoof_button.setText("PROCESSING...")
        self.spoof_button.setEnabled(False)
        self.spoof_status.setText(f"Executing: {', '.join(enabled_modules)}")

        # Simular processamento
        QTimer.singleShot(3000, self.reset_spoof_button)

    def reset_spoof_button(self):
        """Reseta bot√£o ap√≥s processamento"""
        self.spoof_button.setText("START SPOOFING")
        self.spoof_button.setEnabled(True)
        self.spoof_status.setText("Security protocol completed")

        QTimer.singleShot(2000, lambda: self.spoof_status.setText("System ready for spoofing protocol"))

    def update_hardware_stats(self):
        """Atualiza as estat√≠sticas de hardware e os gr√°ficos"""
        try:
            # Buscar dados do Reader
            cpu_percent = self.hw_reader.get_cpu_percent()
            memory_percent = self.hw_reader.get_memory_percent()
            disk_mbs = self.hw_reader.get_disk_mbs() # CHANGED

            # Atualizar Labels
            self.cpu_stat.findChild(QLabel, "hardwareValue").setText(f"{cpu_percent:.0f}%")
            self.memory_stat.findChild(QLabel, "hardwareValue").setText(f"{memory_percent:.0f}%")
            # CHANGED: Format the disk label as MB/s
            self.disk_stat.findChild(QLabel, "hardwareValue").setText(f"{disk_mbs:.0f} MB/s")

            # Atualizar Gr√°ficos
            if hasattr(self, 'cpu_graph'):
                self.cpu_graph.add_data_point(cpu_percent)
            if hasattr(self, 'memory_graph'):
                self.memory_graph.add_data_point(memory_percent)
            if hasattr(self, 'disk_graph'):
                # CHANGED: Calculate the % for the graph
                disk_percent_for_graph = (disk_mbs / DISK_GRAPH_MAX_MB_S) * 100.0
                self.disk_graph.add_data_point(disk_percent_for_graph)

            # Atualizar Status
            if cpu_percent > 80:
                self.status_stat.findChild(QLabel, "hardwareValue").setText("HIGH LOAD")
                self.status_stat.findChild(QLabel, "hardwareValue").setStyleSheet("color: #FF6B6B;")
            elif cpu_percent > 50:
                self.status_stat.findChild(QLabel, "hardwareValue").setText("MODERATE")
                self.status_stat.findChild(QLabel, "hardwareValue").setStyleSheet("color: #FFA726;")
            else:
                self.status_stat.findChild(QLabel, "hardwareValue").setText("OPTIMAL")
                self.status_stat.findChild(QLabel, "hardwareValue").setStyleSheet("color: #B8E986;")

        except Exception as e:
            print(f"Hardware stats update error: {e}")


# Lunar\src\ui\components\hardware_graphs.py

# src/ui/components/hardware_graphs.py

from PySide6.QtWidgets import QWidget
from PySide6.QtCore import Qt, QPointF, QRectF
from PySide6.QtGui import (QPainter, QColor, QBrush, QPolygonF,
                           QLinearGradient, QRadialGradient, QImage) # [NOVO] QImage

class MiniGraphWidget(QWidget):
    def __init__(self, parent=None, max_points=30):
        super().__init__(parent)
        self.max_points = max_points
        self.data_points = [0.0] * self.max_points
        self.graph_color = QColor("#50E3C2") # Cor padr√£o
        self.setFixedSize(100, 40)

        # O "zoom" vertical m√≠nimo que voc√™ sugeriu
        self.MIN_VERTICAL_RANGE = 30

    def set_color(self, color_hex):
        """Define a cor principal do gr√°fico."""
        self.graph_color = QColor(color_hex)
        self.update()

    def add_data_point(self, value):
        """Adiciona um novo ponto de dado e atualiza o gr√°fico."""
        if value < 0: value = 0
        # if value > 100: value = 100  <-- [REMOVIDO]

        self.data_points.append(value)

        while len(self.data_points) > self.max_points:
            self.data_points.pop(0)

        self.update() # Solicita o redesenho

    def paintEvent(self, event):
        """Desenha o gr√°fico com scaling instant√¢neo E FADE NOS DOIS EIXOS."""
        try:
            painter = QPainter(self)
            painter.setRenderHint(QPainter.Antialiasing)

            w = self.width()
            h = self.height()

            if not self.data_points:
                return

            # --- 1. L√≥gica de Scaling Instant√¢neo (Baseado no √∫ltimo ponto) ---
            current_value = self.data_points[-1]
            half_range = self.MIN_VERTICAL_RANGE / 2.0
            graph_min = current_value - half_range
            graph_max = current_value + half_range

            # --- 2. Clamping (Travar a escala apenas em 0) ---
            if graph_min < 0.0:
                overshoot = 0.0 - graph_min
                graph_min = 0.0
                graph_max += overshoot

            # --- 3. Normaliza√ß√£o e C√°lculo do Pol√≠gono ---
            current_range = graph_max - graph_min
            if current_range < 0.01:
                current_range = self.MIN_VERTICAL_RANGE

            polygon = QPolygonF()
            polygon.append(QPointF(0, h)) # Canto inferior esquerdo

            line_polygon = QPolygonF() # Pol√≠gono apenas para a linha

            step_x = w / (self.max_points - 1)

            for i, value in enumerate(self.data_points):
                normalized_y = (value - graph_min) / current_range

                # Clamp de seguran√ßa
                if normalized_y < 0.0: normalized_y = 0.0
                if normalized_y > 1.0: normalized_y = 1.0

                y = h - (normalized_y * h)
                x = i * step_x

                polygon.append(QPointF(x, y))
                line_polygon.append(QPointF(x, y))

            polygon.append(QPointF(w, h)) # Canto inferior direito

            # Cores
            solid_color = QColor(self.graph_color)
            faded_color = QColor(self.graph_color)
            faded_color.setAlphaF(0.0) # 0% opaco

            # --- 4. [ALTERADO] Desenhar o Preenchimento (Fill) em um Buffer ---

            # Criar buffer off-screen para aplicar os dois gradientes
            buffer = QImage(self.size(), QImage.Format_ARGB32_Premultiplied)
            buffer.fill(Qt.transparent)

            buffer_painter = QPainter(buffer)
            buffer_painter.setRenderHint(QPainter.Antialiasing)

            # Etapa 1: Gradiente Vertical (de cima para baixo)
            v_grad = QLinearGradient(0, 0, 0, h)
            v_grad.setColorAt(0.0, solid_color.lighter(120)) # Cor no topo
            v_grad.setColorAt(1.0, faded_color) # Transparente embaixo

            buffer_painter.setPen(Qt.NoPen)
            buffer_painter.setBrush(v_grad)
            buffer_painter.drawPolygon(polygon)

            # **ETAPA 2: APLICAR FADE "EIXO X" (Esquerda E Direita)**
            buffer_painter.setCompositionMode(QPainter.CompositionMode_DestinationIn)

            h_grad_mask = QLinearGradient(0, 0, w, 0)
            h_grad_mask.setColorAt(0.0, QColor(0,0,0,0))   # Esquerda = Transparente
            h_grad_mask.setColorAt(0.8, QColor(0,0,0,255)) # 80% = Opaco (Foco)
            h_grad_mask.setColorAt(1.0, QColor(0,0,0,0))   # Direita = Transparente

            buffer_painter.fillRect(self.rect(), h_grad_mask)
            buffer_painter.end()

            # --- 5. Desenhar o Buffer na Tela ---
            painter.drawImage(0, 0, buffer)

            # --- 6. Desenhar a Linha (com Fade Esquerda/Direita) ---
            h_grad_line = QLinearGradient(0, 0, w, 0)
            h_grad_line.setColorAt(0.0, faded_color) # Esquerda = Transparente
            h_grad_line.setColorAt(0.8, solid_color) # 80% = S√≥lido (Foco)
            h_grad_line.setColorAt(1.0, faded_color) # Direita = Transparente

            pen = painter.pen()
            pen.setBrush(h_grad_line)
            pen.setWidthF(1.5)
            painter.setPen(pen)
            painter.setBrush(Qt.NoBrush)

            painter.drawPolyline(line_polygon)

        except Exception as e:
            print(f"Erro no paintEvent do MiniGraph: {e}")


# Lunar\src\ui\components\hardware_tab.py

# TODO: Implement


# Lunar\src\ui\components\network_selector.py

# TODO: Implement


# Lunar\src\ui\components\particles.py

import random
from PySide6.QtWidgets import QWidget
from PySide6.QtCore import Qt, QTimer, QPointF
from PySide6.QtGui import QPainter, QColor, QBrush

class Particle:
    def __init__(self, x, y, size, color, speed_x, speed_y, opacity):
        self.x = x
        self.y = y
        self.size = size
        self.color = color
        self.speed_x = speed_x
        self.speed_y = speed_y
        self.opacity = opacity
        self.original_opacity = opacity
        self.fade_direction = random.choice([-1, 1])
        self.fade_speed = random.uniform(0.005, 0.02)

class ParticleSystem(QWidget):
    def __init__(self, parent=None, particle_count=60):
        super().__init__(parent)
        self.particles = []
        self.particle_count = particle_count
        self.timer = QTimer()
        self.timer.timeout.connect(self.update_particles)
        self.timer.start(33)  # ~30 FPS
        
        # Configurar para ser completamente transparente
        self.setAttribute(Qt.WA_TransparentForMouseEvents)
        self.setAttribute(Qt.WA_TranslucentBackground)
        
        # Garantir que fique atr√°s de outros widgets
        self.lower()

        # Inicializar part√≠culas apenas quando o widget for mostrado
        self.initialized = False

    def showEvent(self, event):
        """Inicializa part√≠culas quando o widget √© mostrado"""
        if not self.initialized:
            self.init_particles(self.particle_count)
            self.initialized = True
        super().showEvent(event)

    def init_particles(self, count):
        """Inicializa part√≠culas distribu√≠das por toda a √°rea"""
        width = self.width() if self.width() > 0 else 800
        height = self.height() if self.height() > 0 else 600

        # Cores mais vibrantes para serem vis√≠veis atrav√©s do header
        colors = [
            QColor(255, 255, 255),  # Branco puro
            QColor(220, 230, 255),  # Azul muito claro
            QColor(240, 240, 255),  # Branco azulado
            QColor(255, 250, 250),  # Branco levemente rosado
        ]

        self.particles = []
        for _ in range(count):
            # Distribuir part√≠culas por toda a √°rea
            x = random.uniform(0, width)
            y = random.uniform(0, height)
            size = random.uniform(1.0, 3.0)  # Part√≠culas um pouco maiores
            color = random.choice(colors)

            # Velocidades mais lentas
            speed_x = random.uniform(-0.1, 0.1)
            speed_y = random.uniform(-0.1, 0.1)

            # Opacidade mais alta para serem vis√≠veis
            opacity = random.uniform(0.3, 0.8)

            self.particles.append(Particle(x, y, size, color, speed_x, speed_y, opacity))

    def update_particles(self):
        """Atualiza posi√ß√£o e estado das part√≠culas"""
        if not self.isVisible() or not self.initialized:
            return

        width = self.width()
        height = self.height()

        if width <= 0 or height <= 0:
            return

        for particle in self.particles:
            # Atualizar posi√ß√£o
            particle.x += particle.speed_x
            particle.y += particle.speed_y

            # Efeito de fade pulsante
            particle.opacity += particle.fade_speed * particle.fade_direction

            # Garantir que a opacidade fique dentro dos limites v√°lidos
            if particle.opacity >= particle.original_opacity:
                particle.opacity = particle.original_opacity
                particle.fade_direction = -1
            elif particle.opacity <= 0.1:
                particle.opacity = 0.1
                particle.fade_direction = 1

            # Reposicionar part√≠culas que saem da tela
            if particle.x < -50:
                particle.x = width + 50
                particle.y = random.uniform(0, height)
            elif particle.x > width + 50:
                particle.x = -50
                particle.y = random.uniform(0, height)

            if particle.y < -50:
                particle.y = height + 50
                particle.x = random.uniform(0, width)
            elif particle.y > height + 50:
                particle.y = -50
                particle.x = random.uniform(0, width)

        self.update()

    def paintEvent(self, event):
        """Desenha as part√≠culas - CORRIGIDO para evitar erros de QPainter"""
        if not self.initialized or not self.isVisible():
            return

        try:
            painter = QPainter(self)
            if not painter.isActive():
                return
                
            painter.setRenderHint(QPainter.Antialiasing)
            
            # IMPORTANTE: N√£o preencher o fundo - deixar transparente
            painter.setCompositionMode(QPainter.CompositionMode_SourceOver)
            
            for particle in self.particles:
                # Garantir que a opacidade esteja dentro do range v√°lido
                opacity = max(0.05, min(1.0, particle.opacity))

                color = QColor(particle.color)
                color.setAlphaF(opacity)

                painter.setPen(Qt.NoPen)
                painter.setBrush(QBrush(color))

                # Desenhar part√≠cula
                painter.drawEllipse(QPointF(particle.x, particle.y), particle.size, particle.size)
                
            painter.end()
            
        except Exception as e:
            print(f"Erro no ParticleSystem paintEvent: {e}")

    def resizeEvent(self, event):
        """Reinicializa part√≠culas quando o tamanho muda"""
        super().resizeEvent(event)
        if self.initialized and event.oldSize().width() > 0 and event.oldSize().height() > 0:
            old_width = event.oldSize().width()
            old_height = event.oldSize().height()
            new_width = event.size().width()
            new_height = event.size().height()

            scale_x = new_width / old_width
            scale_y = new_height / old_height

            for particle in self.particles:
                particle.x *= scale_x
                particle.y *= scale_y


# Lunar\src\ui\components\progress_indicator.py

# TODO: Implement


# Lunar\src\ui\components\sidebar.py

from PySide6.QtWidgets import (QFrame, QVBoxLayout, QPushButton,
                              QLabel, QSizePolicy)
from PySide6.QtCore import Qt, Signal, QSize
from PySide6.QtGui import QFont, QPixmap, QPainter, QLinearGradient, QColor, QIcon
import os

class Sidebar(QFrame):
    navigation_changed = Signal(str)

    def __init__(self, parent=None):
        super().__init__(parent)
        self.current_page = "dashboard"
        self.setup_ui()

    def setup_ui(self):
        """Configura a sidebar mais estreita"""
        self.setFixedWidth(120)  # Reduzida de 260 para 200
        self.setObjectName("sidebar")

        # Layout principal
        layout = QVBoxLayout(self)
        # ALTERADO (Left, Top, Right, Bottom) de (0, 0, 0, 0) para (0, 30, 0, 0)
        layout.setContentsMargins(0, 25, 0, 0)
        layout.setSpacing(0)

        # Header removido (agora est√° no HeaderBar)

        # Logo no topo
        logo_header = self.create_logo_header()
        layout.addWidget(logo_header)

        # Navega√ß√£o limpa
        nav_buttons = self.create_navigation_buttons()
        layout.addWidget(nav_buttons)

        # Espa√ßo flex√≠vel
        layout.addStretch(1)

        # Footer minimalista
        footer = self.create_footer()
        layout.addWidget(footer)

    def create_header(self):
        """Cria cabe√ßalho minimalista"""
        header_frame = QFrame()
        header_frame.setObjectName("sidebarHeader")
        header_frame.setFixedHeight(100)

        layout = QVBoxLayout(header_frame)
        layout.setContentsMargins(20, 20, 20, 15)

        # Logo elegante
        logo_label = QLabel("LUNAR")
        logo_label.setObjectName("logoLabel")
        logo_label.setAlignment(Qt.AlignCenter)
        logo_label.setFont(QFont("Segoe UI", 18, QFont.Bold))

        # Subt√≠tulo sutil
        subtitle_label = QLabel("SYSTEM PROTECTION")
        subtitle_label.setObjectName("subtitleLabel")
        subtitle_label.setAlignment(Qt.AlignCenter)
        subtitle_label.setFont(QFont("Segoe UI", 8))

        layout.addWidget(logo_label)
        layout.addWidget(subtitle_label)

        return header_frame

    def create_logo_header(self):
        """Cria o header da sidebar com o logo"""
        logo_label = QLabel()
        logo_label.setObjectName("sidebarLogo")
        logo_label.setFixedHeight(80) # Altura similar ao header_bar
        logo_label.setAlignment(Qt.AlignCenter)

        # Carregar √≠cone - caminho correto
        icon_path = os.path.join(os.path.dirname(__file__), '..', '..', '..', 'assets', 'icons', 'logo.png')

        if not os.path.exists(icon_path):
             # Fallback para pasta local de icons
             icon_path = os.path.join(os.path.dirname(__file__), '..', 'icons', 'logo.png')

        if os.path.exists(icon_path):
            pixmap = QPixmap(icon_path)
            pixmap = pixmap.scaled(64, 64, Qt.KeepAspectRatio, Qt.SmoothTransformation)
            logo_label.setPixmap(pixmap)
        else:
            print(f"Logo n√£o encontrado: {icon_path}")
            logo_label.setText("LUNAR") # Fallback
            logo_label.setFont(QFont("Segoe UI", 18, QFont.Bold))
            logo_label.setStyleSheet("color: white;")

        return logo_label

    def create_navigation_buttons(self):
        """Cria bot√µes de navega√ß√£o minimalistas"""
        nav_frame = QFrame()
        nav_frame.setObjectName("navFrame")

        layout = QVBoxLayout(nav_frame)
        layout.setContentsMargins(10, 20, 10, 20)  # Margens reduzidas
        layout.setSpacing(6) # Espa√ßamento dobrado (3 -> 6)

        # Bot√µes atualizados
        nav_items = [
            # (Texto p/ ToolTip, page_id, icon_filename, is_active)
            ("Dashboard", "dashboard", "dashboard.png", True),
            ("Security Tools", "tools", "stools.png", False),
            ("System Info", "system_info", "sinfo.png", False),
            ("Settings", "settings", "settings.png", False)
        ]

        self.nav_buttons = {}

        for text, page_id, icon_name, is_active in nav_items:
            btn = QPushButton() # Criar bot√£o sem texto
            btn.setToolTip(text) # Adicionar o texto como dica
            btn.setObjectName(f"navButton_{page_id}")
            btn.setCursor(Qt.PointingHandCursor)
            btn.setFixedHeight(108)  # Altura aumentada (72 -> 108)
            btn.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)

            # L√≥gica para adicionar √≠cone
            icon_path = os.path.join(os.path.dirname(__file__), '..', '..', '..', 'assets', 'icons', icon_name)

            if not os.path.exists(icon_path):
                icon_path = os.path.join(os.path.dirname(__file__), '..', 'icons', icon_name)

            if os.path.exists(icon_path):
                pixmap = QPixmap(icon_path)
                btn.setIcon(QIcon(pixmap))
                btn.setIconSize(QSize(54, 54)) # √çcone aumentado (36 -> 54)
            else:
                print(f"√çcone de navega√ß√£o n√£o encontrado: {icon_path}")
                btn.setText(text) # Fallback para texto se √≠cone falhar

            # Conectar sinal
            btn.clicked.connect(lambda checked, pid=page_id: self.on_navigation_click(pid))

            # Estado ativo
            if is_active:
                self.set_button_active(btn, True)

            layout.addWidget(btn)
            self.nav_buttons[page_id] = btn

        return nav_frame

    def create_footer(self):
        """Cria rodap√© minimalista"""
        footer_frame = QFrame()
        footer_frame.setObjectName("footerFrame")
        footer_frame.setFixedHeight(60)

        layout = QVBoxLayout(footer_frame)
        layout.setContentsMargins(10, 8, 10, 8)
        layout.setSpacing(4)

        # Status
        status_label = QLabel("‚óè SECURE")
        status_label.setObjectName("statusLabel")
        status_label.setAlignment(Qt.AlignCenter)
        status_label.setFont(QFont("Segoe UI", 9, QFont.Bold))

        layout.addStretch(1)
        layout.addWidget(status_label)

        return footer_frame

    def on_navigation_click(self, page_id):
        """Handler para navega√ß√£o"""
        # Atualizar estados dos bot√µes
        for pid, btn in self.nav_buttons.items():
            self.set_button_active(btn, pid == page_id)

        self.current_page = page_id
        self.navigation_changed.emit(page_id)

    def set_button_active(self, button, active):
        """Define estado ativo do bot√£o"""
        button.setProperty("active", "true" if active else "false")
        button.style().unpolish(button)
        button.style().polish(button)


# Lunar\src\ui\components\software_tab.py

# TODO: Implement


# Lunar\src\ui\components\spoofing_panel.py

# TODO: Implement


# Lunar\src\ui\components\switch.py

from PySide6.QtWidgets import QWidget
from PySide6.QtCore import Qt, QPropertyAnimation, QEasingCurve, Signal, Property
from PySide6.QtGui import QPainter, QColor, QPen, QBrush

class SwitchButton(QWidget):
    toggled = Signal(bool)

    def __init__(self, parent=None, width=50, height=24):
        super().__init__(parent)
        self._checked = False
        self._circle_position = 3
        self._width = width
        self._height = height

        # Anima√ß√£o
        self._animation = QPropertyAnimation(self, b"circle_position")
        self._animation.setDuration(200)
        self._animation.setEasingCurve(QEasingCurve.InOutQuad)

        self.setFixedSize(self._width, self._height)
        self.setCursor(Qt.PointingHandCursor)

    def get_circle_position(self):
        return self._circle_position

    def set_circle_position(self, pos):
        self._circle_position = pos
        self.update()

    circle_position = Property(float, get_circle_position, set_circle_position)

    def isChecked(self):
        return self._checked

    def setChecked(self, checked):
        if self._checked != checked:
            self._checked = checked
            self.toggled.emit(checked)
            self.animate_switch(checked)

    def animate_switch(self, checked):
        start = 3
        end = self._width - 21  # width - (circle diameter + margin)
        if not checked:
            start, end = end, start

        self._animation.setStartValue(start)
        self._animation.setEndValue(end)
        self._animation.start()

    def paintEvent(self, event):
        painter = QPainter(self)
        painter.setRenderHint(QPainter.Antialiasing)

        # Fundo do switch
        if self._checked:
            bg_color = QColor("#4a90e2")  # Azul quando ativo
            border_color = QColor("#357abd")
        else:
            bg_color = QColor("#333333")  # Cinza quando inativo
            border_color = QColor("#555555")

        # Desenhar fundo
        painter.setPen(QPen(border_color, 1))
        painter.setBrush(QBrush(bg_color))
        painter.drawRoundedRect(0, 0, self._width, self._height, self._height // 2, self._height // 2)

        # C√≠rculo deslizante
        circle_color = QColor("#ffffff")
        painter.setPen(Qt.NoPen)
        painter.setBrush(QBrush(circle_color))
        painter.drawEllipse(int(self._circle_position), 3, 18, 18)

    def mousePressEvent(self, event):
        if event.button() == Qt.LeftButton:
            self.setChecked(not self._checked)

    def enterEvent(self, event):
        self.setCursor(Qt.PointingHandCursor)
        super().enterEvent(event)

    def leaveEvent(self, event):
        self.setCursor(Qt.ArrowCursor)
        super().leaveEvent(event)


# Lunar\src\ui\components\system_stats.py

# TODO: Implement


# Lunar\src\ui\components\toast_notification.py

# TODO: Implement


# Lunar\src\ui\styles\main.css

/* ===== RESET PARA QFRAME ===== */
QFrame {
    background: transparent;
    border: none;
}

/* Garantir que os QFrames espec√≠ficos tenham seus estilos */
#sidebar, #dashboard, #contentArea, #contentStack {
    background: transparent;
}

/* ===== ESTILOS GERAIS ===== */
QMainWindow {
    background: #141414;
    color: #ffffff;
    font-family: "Segoe UI", system-ui;
    font-size: 13px;
}

#centralWidget {
    background: #141414;
}

QWidget {
    background: transparent;
    color: #ffffff;
    border: none;
}

/* ===== HEADER BAR - REMOVED ===== */
/* The #iconButton and #userWidget styles still work */

/* BOT√ïES DO HEADER - SEM FUNDO (APENAS HOVER) */
#iconButton {
    background: transparent;
    border: none;
    border-radius: 6px;
    padding: 6px;
}

#iconButton:hover {
    background: rgba(255, 255, 255, 0.1);
}

#iconButton:pressed {
    background: rgba(255, 255, 255, 0.15);
}

#userWidget {
    background: transparent;
    border: none;
    border-radius: 6px;
    padding: 0px;
}

#userLabel {
    color: #ffffff;
    background: transparent;
    font-size: 12px;
    font-weight: bold;
}

#roleLabel {
    color: #cccccc;
    background: transparent;
    font-size: 9px;
}

/* ===== SIDEBAR - SEMI-TRANSPARENTE PARA VER PART√çCULAS ===== */
#sidebar {
    background: rgba(30, 30, 30, 0.6);
    border-right: 2px solid rgba(20, 20, 20, 0.5);
}

#navFrame {
    background: transparent;
    border: none;
}

QPushButton[navButton] {
    background: transparent;
    color: #b0b0b0;
    border: none;
    border-radius: 4px;
    padding: 8px 12px;
    margin: 1px 4px;
    font-size: 11px;
    font-weight: 500;
    text-align: left;
}

QPushButton[navButton]:hover {
    background: rgba(255, 255, 255, 0.08);
    color: #ffffff;
}

QPushButton[navButton][active="true"] {
    background: rgba(74, 144, 226, 0.15);
    color: #4a90e2;
    border-left: 2px solid #4a90e2;
    font-weight: 600;
}

#footerFrame {
    background: rgba(30, 30, 30, 0.6);
    border-top: 2px solid rgba(20, 20, 20, 0.5);
}

#statusLabel {
    color: #50e3c2;
    background: transparent;
    font-size: 9px;
    font-weight: 600;
}

/* ===== DASHBOARD ===== */
#dashboard {
    background: transparent;
}

#contentFrame {
    background: transparent;
    border: none;
}

/* ===== PAINEL DE HARDWARE ===== */
#hardwarePanel {
    background: rgba(30, 30, 30, 0.9);
    border: 1px solid #2a2a2a;
    border-radius: 12px;
}

/* ===== PAINEL DE HARDWARE (PILL) ===== */
#pillHardwarePanel {
    background: rgba(30, 30, 30, 0.9);
    border: 1px solid #2a2a2a;
    border-radius: 30px;
}

#hardwareStat {
    background: transparent;
    border: none;
}

#hardwareTitle {
    color: #b0b0b0;
    background: transparent;
    font-size: 10px;
    font-weight: 500;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

#hardwareValue {
    background: transparent;
    font-size: 16px;
    font-weight: bold;
}

/* ===== PAINEL DE A√á√ïES ===== */
#actionPanel {
    background: transparent;
    border: none;
}

#buttonContainer {
    background: rgba(30, 30, 30, 0.6);
    border: 1px solid #2a2a2a;
    border-radius: 12px;
}

#sectionTitle {
    color: #ffffff;
    background: transparent;
    font-size: 16px;
    font-weight: bold;
}

/* BOT√ÉO PRINCIPAL */
#mainSpoofButton {
    background: qlineargradient(x1:0, y1:0, x2:1, y2:0, stop:0 #4a90e2, stop:1 #50e3c2);
    color: #000000;
    border: none;
    border-radius: 8px;
    font-size: 13px;
    font-weight: bold;
    padding: 14px 28px;
    letter-spacing: 0.5px;
    text-transform: uppercase;
}

#mainSpoofButton:hover {
    background: qlineargradient(x1:0, y1:0, x2:1, y2:0, stop:0 #5a9fee, stop:1 #60f3d2);
}

#mainSpoofButton:pressed {
    background: qlineargradient(x1:0, y1:0, x2:1, y2:0, stop:0 #3a80d2, stop:1 #40d3b2);
}

#mainSpoofButton:disabled {
    background: #2a2a2a;
    color: #666666;
}

#spoofStatus {
    color: #b0b0b0;
    background: transparent;
    font-size: 11px;
    padding: 8px;
}

/* ===== M√ìDULOS ===== */
#modulesPanel {
    background: rgba(30, 30, 30, 0.6);
    border: 1px solid #2a2a2a;
    border-radius: 12px;
}

#modulesTitle {
    color: #ffffff;
    background: transparent;
    font-size: 12px;
    font-weight: bold;
    text-transform: uppercase;
    letter-spacing: 1px;
}

QFrame[switchRow] {
    background: transparent;
    border: none;
    border-radius: 4px;
}

QFrame[switchRow]:hover {
    background: rgba(255, 255, 255, 0.05);
}

#moduleName {
    color: #e0e0e0;
    background: transparent;
    font-size: 11px;
    font-weight: 500;
}

/* ===== SWITCH BUTTON ===== */
SwitchButton {
    background-color: #333333;
    border: 2px solid #444444;
    border-radius: 10px;
}

SwitchButton:hover {
    background-color: #3a3a3a;
    border: 2px solid #4a4a4a;
}

SwitchButton:checked {
    background-color: #4a90e2;
    border: 2px solid #4a90e2;
}

SwitchButton:checked:hover {
    background-color: #5a9fee;
    border: 2px solid #5a9fee;
}

SwitchButton::handle {
    background-color: #ffffff;
    border: none;
    border-radius: 8px;
}

/* ===== BARRA DE STATUS ===== */
QStatusBar {
    background: #1a1a1a;
    color: #b0b0b0;
    border-top: 1px solid #2a2a2a;
    padding: 6px 15px;
    font-size: 10px;
}

/* ===== SCROLLBARS ===== */
QScrollBar:vertical {
    background: #252525;
    width: 8px;
    margin: 0px;
    border-radius: 4px;
}

QScrollBar::handle:vertical {
    background: #333333;
    border-radius: 4px;
    min-height: 20px;
}

QScrollBar::handle:vertical:hover {
    background: #444444;
}

/* Sistema de part√≠culas */
ParticleSystem {
    background: transparent;
    border: none;
}


# Lunar\src\ui\styles\components\buttons.css

/* TODO: Add styles */


# Lunar\src\ui\styles\components\cards.css

/* TODO: Add styles */


# Lunar\src\ui\styles\components\logs.css

/* TODO: Add styles */


# Lunar\src\ui\styles\components\progress.css

/* TODO: Add styles */


# Lunar\src\ui\styles\components\sidebar.css

/* TODO: Add styles */


# Lunar\src\ui\styles\components\tabs.css

/* TODO: Add styles */


# Lunar\src\ui\styles\themes\cyan.css

/* TODO: Add styles */


# Lunar\src\ui\styles\themes\dark.css

/* TODO: Add styles */


# Lunar\src\ui\styles\themes\purple.css

/* TODO: Add styles */


# Lunar\src\utils\admin_check.py

# TODO: Implement


# Lunar\src\utils\hardware_reader.py

# src/utils/hardware_reader.py

import psutil
import traceback
import time # NEW IMPORT

class HardwareReader:
    def __init__(self):
        """Inicializa o leitor de hardware."""
        # Inicializar o psutil para a CPU
        psutil.cpu_percent(interval=None)

        # NEW: Inicializar contadores de Disco
        # Pegar os contadores totais (sem ser por parti√ß√£o)
        self.last_disk_io = psutil.disk_io_counters(perdisk=False)
        self.last_disk_time = time.time()

    def get_cpu_percent(self):
        """Retorna o uso atual da CPU em %."""
        try:
            return psutil.cpu_percent(interval=None)
        except Exception:
            return 0.0

    def get_memory_percent(self):
        """Retorna o uso atual da mem√≥ria em %."""
        try:
            memory = psutil.virtual_memory()
            return memory.percent
        except Exception:
            return 0.0

    def get_disk_mbs(self): # CHANGED: Name and logic
        """Retorna a atividade de R/W do disco em MB/s."""
        try:
            current_disk_io = psutil.disk_io_counters(perdisk=False)
            current_disk_time = time.time()

            # Delta de tempo (em segundos)
            time_delta = current_disk_time - self.last_disk_time
            if time_delta == 0:
                # Evita divis√£o por zero se chamado r√°pido demais
                return 0.0

            # Calcular bytes lidos/escritos no intervalo
            read_delta = current_disk_io.read_bytes - self.last_disk_io.read_bytes
            write_delta = current_disk_io.write_bytes - self.last_disk_io.write_bytes
            total_bytes_delta = read_delta + write_delta

            # Calcular MB/s
            bytes_per_second = total_bytes_delta / time_delta
            mb_per_second = bytes_per_second / (1024 * 1024) # 1 MB = 1024*1024 Bytes

            # Atualizar "last" para o pr√≥ximo c√°lculo
            self.last_disk_io = current_disk_io
            self.last_disk_time = current_disk_time

            return mb_per_second

        except Exception as e:
            print(f"Erro ao ler atividade do disco (MB/s): {e}")
            return 0.0


# Lunar\src\utils\icon_manager.py

# TODO: Implement


# Lunar\src\utils\logger.py

# TODO: Implement


# Lunar\src\utils\registry_checker.py

# TODO: Implement


# Lunar\tests\test_auth.py

# TODO: Implement


# Lunar\tests\test_spoofers.py

# TODO: Implement


# Lunar\tests\test_ui.py

# TODO: Implement


